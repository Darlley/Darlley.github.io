! function (e) {function t (r) {if (n [r]) retorna n [r] .exporta; var o = n [r] = {i: r, l:! 1, exporta: {}} ; return e [r] .call (o.exports, o, o.exports, t), ol =! 0, o.exports} var n = {}; tm = e, tc = n, td = function (e , n, r) {para (e, n) || Object.defineProperty (e, n, {configurável:! 1, enumerável:! 0, get: r})}, tn = function (e) {var n = e && e .__ esModule? function () {retornar e.default}: function () {return e}; retornar td (n, "a", n), n}, para = function (e, t) {return Object.prototype .hasOwnProperty.call (e, t)}, tp = "/ build /", t (ts = 28)} ([function (e, t, n) {"use strict"; e.exports = n (29) } função (e, t, n) {e.exportações = n (48) ()}, função (e, t, n) {"use strict"; var r = function () {}; e.exports = r}, function (e, t, n) {"use strict"; function r (e) {return e && e .__ esModule? e: {padrão: e}} function o (e, t) {var n = {}; for (var r in e) t.indexOf (r)> = 0 || Object.prototype.hasOwnProperty.call (e,r) && (n [r] = e [r]); return n} Object.defineProperty (t, "__ esModule", {value:! 0}), t.Li = t.Code = void 0; var a = Função Object.assign || (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n , r) && (e [r] = n [r])} retornam e}, i = n (0), u = r (i), s = n (1), c = r (s), l = {normal: {borderBottom: "1px rgb pontilhado (0, 168, 0)"}, passe o mouse: {borderBottom: "1px rgb sólido (0, 168, 0)", cor: "preto"}, ativo: "hover" , touchActive: {borderBottom: "1px rgb tracejado (0, 168, 0)", cor: "preto"}, focusFromTab: {outline: "2px rgb sólido (0, 152, 0)", outlineOffset: "2px", color: "black"}, touchActiveTapOnly:! 0}, p = {}; Object.keys (l) .forEach (function (e) {"touchActiveTapOnly"! == e && (p ["onParent" + e.slice ( 0,1) .toUpperCase () + e.fatia (1)] = l [e])}), t.default = {link: l, childLink: p, p: {margin: "3vh 0", lineHeight: "1.4"}}, (t.Code = função (e) {var t = e.children; retornar u.default.createElement ("código", {estilo: {fontFamily: "monospace", fontSize: "15px", paddingLeft: "2px"}}, t)} ) .propTypes = {children: c.default.string.isRequired}; var f = function (e) {var t = e.children, n = o (e, ["children"])); retorne u.default.createElement ("li", a ({style: {paddingLeft: "18px", textIndent: "- 15px", margem: "0.5vh 0", listStyle: "none"}}, n), u.default.createElement (" span ", {style: {paddingRight:" 7px "}}," - "), t)}; t.Li = f, f.propTypes = {filhos: c.default.string.isRequired}}, função (e , t, n) {"use strict"; função r (e, t) {return "select"! == e && ("input"! == e || "caixa de seleção "! == t &&" radio "! == t)} função o (e, t) {retornar" botão "=== e ||" selecionar "=== e ||" input "=== e && ( "caixa de seleção" === t || "rádio" === t || "enviar" === t)} função a (e) {retornar {tipo: e, persistir: função () {}, preventDefault: function () {}, stopPropagation: function () {}}} Object.defineProperty (t, "__ esModule", {valor:! 0}), t.childInteractiveProps = t.defaultTapTimeCutoff = t.queueTime = t.knownProps = t. knownRoleTags = t.nonBlurrableTags = t.statePropOptionKeys = t.stateProps = t.iStates = t.otherEvents = t.touchEvents = t.mouseEvents = t.passiveEventSupport = t.deviceHasMouse = t.deviceHasTouch = t.deviceType; i = Object.assign || função (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retorne e}; t.enterKeyTrigger = r, t.spaceKeyTrigger = o, t.dummyEvent = a; var u = n (81), s = função (e) {retornar e && e .__ esModule? e: {padrão: e}} (u), c = (t.deviceType = s.default.deviceType, t.deviceHasTouch = s.default.hasTouch, t.deviceHasMouse = s.default.hasMouse, t.passiveEventSupport = s.default.passiveEvents, t.mouseEvents = {mouseenter: "onMouseEnvent ", mouseleave:" onMouseLeave ", mousemove:" onMouseMove ", mousedown:" onMouseDown ", mouseup:" onMouseUp "}, t.touchEvents = {touchstart:" onTouchStart ", toque:" onTouchEnd ", touchcancel:" onTouchCancel: "} ; ! 0, hover:! 0, hoverActive:! 0, touchActive:! 0, keyActive:! 0}), l = t.stateProps = i ({}, c, {ativo:! 0, foco:! 0, focusFromTab:! 0, focusFromMouse:! 0, focusFromTouch:! 0}), p = (t.statePropOptionKeys = ["style", " className "], t.nonBlurrableTags = {input:! 0, área de texto:! 0, selecione:! 0}); t.knownRoleTags = i ({}, p, {button:! 0, a:! 0, área: ! 0}), t.knownProps = i ({}, l, {filhos:! 0, como:! 0, estilo:! 0, className:! 0, wrapperStyle:! 0, wrapperClassName:! 0, onStateChange :! 0, setStateCallback:! 0, onClick:! 0, onTapTwo:! 0, onTapThree:! 0, onTapFour:! 0, onLongPress:! 0, tapTimeCutoff:! 0, onMouseEnter:! 0, onMouseLeave:! 0, onMouseMove :! 0, onMouseDown:! 0, onMouseUp:! 0, onTouchStart:! 0, onTouchMove:! 0, onTouchEnd:! 0, onTouchCancel:! 0, onFocus:! 0, onBlur:! 0, onKeyDown:! 0, onKeyUp:! 0, forceState:! 0, initialState:! 0, refDOMNode:! 0, mutableProps:! 0, useBrowserOutlineFocus:! 0, useBrowserCursor:! 0, touchActiveTapOnly:! 0, extraTouchNoTap:! 0, focusToggleOff:! 0, stylePriority :! 0, nonContainedChild :!0, InteractiveChild:! 0}), t.queueTime = 600, t.defaultTapTimeCutoff = 500, t.childInteractiveProps = {showOnParent:! 0, onParentNormal:! 0, onParentHover:! 0, onParentActive:! 0, onParentHoverActive:! , onParentTouchActive:! 0, onParentKeyActive:! 0, onParentFocus:! 0, onParentFocusFromTab:! 0, onParentFocusFromMouse:! 0, onParentFocusFromTouch:! 0}}, função (e, t, n) {"use strict"; Object. (t, "__ esModule", {value:! 0}); var r = n (47); nd (t, "BrowserRouter", função () {return ra}); var o = n (53); nd ( t, "HashRouter", function () {return oa}); var a = n (23); nd (t, "Link", função () {return aa}); vari = n (56); nd ( t, "MemoryRouter", function () {return ia}); var u = n (59); nd (t, "NavLink", function () {return ua}); var s = n (62); nd ( t, "Prompt", function () {return sa}); var c = n (64); nd (t, "Redirecionar",function () {return ca}); var l = n (24); nd (t, "Rota", function () {return la}); var p = n (14); nd (t, "Roteador", function () {return pa}); var f = n (70); nd (t, "StaticRouter", function () {return fa}); var d = n (72); nd (t, "Switch", function () {return da}); var h = n (74); nd (t, "matchPath", function () {return ha}); var m = n (75); nd (t, "withRouter", function () {return ma})}, function (e, t, n) {"use strict"; var r = function (e, t, n, r, o, a, i, u) {if (! e ) {var s; if (void 0 === t) s = new Error ("Ocorreu uma exceção minimizada; use o ambiente de desenvolvimento não minificado para obter a mensagem de erro completa e outros avisos úteis."); else {var c = [ n, r, o, a, i, u], l = 0; s = novo Erro (t.replace (/% s / g, função () {retorno c [l ++]})), s.name = " Violação invariável "} throw s.framesToPop = 1, s}}; e.exports = r}, função (e, t, n) {" use strict "; t.__esModule =! 0; var r = (t.addLeadingSlash = função (e) {return "/" === e.charAt (0)? e: "/" + e}, t.stripLeadingSlash = function (e) { return "/" === e.charAt (0)? e.substr (1): e}, t.hasBasename = function (e, t) {retorna novo RegExp ("^" + t + "(\\ / | \\? | # | $) "," i "). test (e)}); t.stripBasename = function (e, t) {return r (e, t)? e.substr (comprimento de t): e}, t.stripTrailingSlash = função (e) {return "/" === e.charAt (e.length-1)? e.slice (0, -1): e}, t.parsePath = function (e ) {var t = e || "/", n = "", r = "", o = t.indexOf ("#"); - 1! == o && (r = t.substr (o), t = t.substr (0, o)); var a = t.indexOf ("?"); return-1! == a && (n = t.substr (a), t = t.substr (0, a) ), {nome do caminho: t, pesquisa: "?" === n? "": n, hash: "#" === r? "": r}}, t.createPath = function (e) {var t = nome do caminho, n = e.search, r = e.hash, o = t || "/ "; return n &&"? "! == n && (o + ="? "=== n.charAt (0)? n:"? "+ n), r &&" # "! == r && (o + =" # "=== r.charAt (0)? r:" # "+ r), o}}, função (e, t, n) {" use strict "; nd (t," a ", function () { return r}), nd (t, "f", function () {return o}), nd (t, "c", function () {return a}), nd (t, "e", function () {return i}), nd (t, "g", função () {return u}), nd (t, "d", função () {return s}), nd (t, "b", função ( ) {return c}); var r = function (e) {return "/" === e.charAt (0)? e: "/" + e}, o = function (e) {return "/" = == e.charAt (0)? e.substr (1): e}, a = function (e, t) {retorna novo RegExp ("^" + t + "(\\ / | \\? | # | $ ) "," i "). teste (e)}, i = função (e, t) {retorna a (e, t)? e.substr (comprimento): e}, u = função (e) { retornar "/" === e.charAt (e.length-1)? e.slice (0, -1): e}, s = função (e) {var t = e || "/", n = "", r = "", o = t.indexOf ("#"); - 1! == o && (r = t.substr (o), t = t.substr (0, o)); var a = t.indexOf ("?"); return-1! == a && (n = t.substr (a), t = t.substr (0, a)), {nome do caminho: t, search: "?" === n? "": n, hash : "#" === r? "": r}}, c = função (e) {var t = nome do caminho, n = e.search, r = e.hash, o = t || "/" ; return n && "?"! == n && (o + = "?" === n.charAt (0)? n: "?" + n), r && "#"! == r && (o + = "#" = == r.charAt (0)? r: "#" + r), o}}, função (e, t, n) {"use strict"; função r (e) {return e && e .__ esModule? e: { padrão: e}} função o (e, t) {if (! (instância de t)) lança novo TypeError ("Não é possível chamar uma classe como uma função")} função a (e, t) {if (!e) lança o novo ReferenceError ("isso não foi inicializado - super () não foi chamado"); return! t || "objeto"! = typeof t && "function"! = typeof t? e: t} function i (e, t) {if ("function"! = typeof && null! == t) lança novo TypeError ("A super expressão deve ser nula ou uma função, não" + typeof t); e.prototype = Object.create (t && t.prototype, {construtor: {valor: e, enumerável:! 1, gravável:! 0, configurável:! 0}}), t && (Object.setPrototypeOf? Object.setPrototypeOf (e, t): e .__ proto __ = t)} Object.defineProperty (t, "__ esModule", {valor:! 0}); var u = Object.assign || função (e) {para (var t = 1; t <argumentos.length; t ++) { var n = argumentos [t]; para (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retornar e}, s = function () { função e (e, t) {para (var n = 0; n <comprimento t; n ++) {var r = t [n]; r.enumerable = r.enumerable ||! 1, r.configurable =! 0, "value" em r && (r.writable =! 0), Object.defineProperty (e, r.key, r)}} função de retorno (t, n, r) {retornar n && e (t.prototype, n), r && e (t, r), t}} (), c = n (0), l = r (c), p = n (79), f = r (p), d = n (80), h = n (86), m = r (h), y = n (87), v = r (y), g = n (88), b = n (89), k = r (b), w = n (90), C = r (w), T = n (18), E = n (91), P = r (E), O = n (4), S = função (e) {função t (e) {o (isto, t); var n = a (isto, (t .__ proto__ || Object.getPrototypeOf (t)). Call (this, e )); return n.refCallback = function (e) {if (n.refNode = e, e) {var t = n.topNode; "string"! = tipo de npprops.as?n.topNode=e.firstChild:n .topNode = e, n.tagName = n.topNode.tagName.toLowerCase (), n.type = n.topNode.type && n.topNode.type.toLowerCase (), n.enterKeyTrigger = (0, O.enterKeyTrigger) (n .tagName, n.type), n.spaceKeyTrigger = (0, O.spaceKeyTrigger) (n.tagName, n.type), n.setClickListener (npprops) && (nppassThroughProps.onClick = n.handleEvent), t! == n.topNode && (n.manageFocus ("refCallback"), npprops.refDOMNode && n.p.props.refDOMNode (n.topNode))}}, n.handleEvent = function ( e) {if (n.isValidEvent (e)) {if (O.mouseEvents [e.type]) {if ("terminate" === n.handleMouseEvent (e)) retornar} else if (O.touchEvents [e .type] || "touchmove" === e.type || "touchtapcancel" === e.type) {if ("terminate" === n.handleTouchEvent (e)) retorna} else if ("click" === e.type) {if ("terminate" === n.handleClickEvent (e)) return} else if ("terminate" === n.handleOtherEvent (e)) return; n.updateState (n.computeState (), npprops, e)}}, n.handleNotifyOfNext = function (e) {var t =! 1; switch (e.type) {case "scroll": case "mouseenter": case "mouseenter": case "mutation": if (n .track.mouseOn && "mouseOn" === n.checkMousePosition ()) retorna "reNotifyOfNext"; n.track.mouseOn =! 1, n.track.buttonDown =! 1, t =! 0; break; case "touchstart": if (npprops.extraTouchNoTap) {if (n. track.touches.active <n.maxTapPoints && (0, k.default) (n.topNode, função (t) {retornar e.target === t})) retornar "reNotifyOfNext"; t = "updateState" === n.handleTouchEvent ({type: "touchtapcancel"})} break; case "dragstart": n.manageSetTimeout ("dragstart", function () {n.track.drag || (n.forceTrackIState ("normal"), n .updateState (n.computeState (), npprops, e,! 0))}, 30); break; case "focus":! 1! == n.track.previousFocus && (n.track.reinstateFocus =! 0, n .manageSetTimeout ("windowFocus", function () {n.track.reinstateFocus =! 1}, O.queueTime)); break; case "blur": n.cancelTimeout ("elementBlur"), n.track.notifyOfNext.foco || (n.track.notifyOfNext.focus = (0, T.notifyOfNext) ("foco", n.handleNotifyOfNext))} retornar t && n.updateState (n.computeState (), npprops, e,! 0), excluir n.track.notifyOfNext [e.type], null}, n.state = {iState: "normal", foco:! 1}, n.track = {touchDown:! 1, recentTouch:! 1, toca em: {pontos : {}, ativo: 0}, mouseOn:! 1, buttonDown:! 1, clickType: "redefinir", foco:! 1, foco anterior:! 1, restabelecer foco:! 1, focusTransição: redefinir, focusStateOnMouseDown:! 1 , spaceKeyDown:! 1, digite KeyDown:! 1, arraste:! 1, updateTopNode:! 1, notifyOfNext: {}, timeoutIDs: {}, estado: n.state}, n.refNode = null, n.topNode = null, n.tagName = "string" == tipo de e.as && e.as || "", n.type = e.type || "", n.enterKeyTrigger =! 1, n.spaceKeyTrigger =! 1, n.maxTapPoints = 1, n.eventHandlers = n.setupEventHandlers (), np = {sameProps:! 1}, n.propsSetup (e), npprops.initialState && n.p.props.initialState.iState && (n.forceTrackIState (npprops.initialState.iState), n.state = n.computeState ()), n} retornar i (t, e), s (t, [{key: "componentDidMount", valor: function () {this.p.props.initialState && void 0! == this.p.props.initialState.focus && this.forceState ({focus: this.p.props.initialState.focus})}}, {key: "componentWillReceiveProps", valor: function (e) {this.track.updateTopNode = this.props.as! == e.as && "string"! = tipo de this.props.as && "string"! = tipo de e. como, this.p.sameProps =! 1,! e.mutableProps && (0, m.default) (this.props, e)? this.p.sameProps =! 0: this.propsSetup (e), this.p. props.forceState && this.forceState (this.p.props.forceState)}}, {key: "shouldComponentUpdate", valor: function (e, t) {return! this.p.sameProps && e == this.props || e. InteractiveChild || t.iState! == this.state.iState && (this.p [t.iState + "Style"]. style! == this.p [this.state.iState + "Style"]. style || this.p [t.iState + "Style"]. ClassName! == this.p [this.state.iState + "Style"] className) || t.focus! == this.state.focus}}, {key: "componentDidUpdate", valor: function () {this.track.updateTopNode && (this.track.updateTopNode =! 1, this.refCallback (this.refNode))}}, {chave: "componentWillUnmount", valor: function () {var e = this; Object .keys (this.track.notifyOfNext) .forEach (function (t) {(0, T.cancelNotifyOfNext) (t, e.track.notifyOfNext [t])}), Object.keys (this.track.timeoutIDs). forEach (function (t) {window.clearTimeout (e.track.timeoutIDs [t])})}}, {chave: "setupEventHandlers", valor: function () {var e = this, t = {}; return Object .keys (O.otherEvents) .forEach (function (n) {t [O.otherEvents [n]] = e.handleEvent}), O.deviceHasTouch && Object.keys (O.touchEvents) .forEach (function (n) {t [O.touchEvents [n]] = e.handleEvent}), O.deviceHasMouse && Object.keys (O.mouseEvents) .forEach (function (n) { t [O.mouseEvents [n]] = e.handleEvent}), t}}, {chave: "setClickListener", valor: função (e) {if (e.onClick) retorna! 0; if (O.deviceHasTouch) {if (e.tabIndex) return! 0; if (O.knownRoleTags [this.tagName]) return! 0} return! 1}}, {key: "propsSetup", valor: function (e) {var t = ( 0, v.default) (e, O.knownProps), n = t.mergedProps, r = t.passThroughProps; (0, g.setActiveAndFocusProps) (n), null === r.tabIndex? Delete r.tabIndex: ! r.tabIndex && (n.focus || n.focusFromTab || n.focusFromMouse || n.focusFromTouch || n.onClick) && (n.tabIndex = "0", r.tabIndex = "0"), null = == r.role? delete r.role:! n.onClique || n.role || "string"! = tipo de n.as || O.knownRoleTags [n.as] || (n.role = "botão ", r.role =" botão "), this.maxTapPoints = n.onTapFour && 4 || n.onTapThree && 3 || n.onTapTwo && 2 || 1, this.setClickListener (n) && (r.onClick = this.handleEvent), O.deviceHasTouch && (n.touchActiveTapOnly || n.onLongPress || n.onTouchMove) && (r.onTouchMove = this.handleEvent), (0, defeito padrão) (r, this.eventHandlers), this.p.normalStyle = (0, g.extractStyle) (n, "normal"), this.p.hoverStyle = (0, g.extractStyle) (n, "pairar"), this.p.hoverActiveStyle = (0, g.extractStyle) ( n, "hoverActive"), this.p.touchActiveStyle = (0, g.extractStyle) (n, "touchActive"), this.p.keyActiveStyle = (0, g.extractStyle) (n, "keyActive"), este .p.tabFocusStyle = (0, g.extractStyle) (n, "focusFromTab"), this.p.mouseFocusStyle = (0, g.extractStyle) (n, "focusFromMouse"), this.p.touchFocusStyle = (0, g.extractStyle) (n,"focusFromTouch"), this.p.passThroughProps = r, this.p.props = n}}, {chave: "manageSetTimeout", valor: function (e, t, n) {var r = this; void 0! = = this.track.timeoutIDs [e] && window.clearTimeout (this.track.timeoutIDs [e]), this.track.timeoutIDs [e] = window.setTimeout (function () {delete r.track.timeoutIDs [e], t ()}, n)}}, {chave: "cancelTimeout", valor: função (e) {void 0! == this.track.timeoutIDs [e] && (window.clearTimeout (this.track.timeoutIDs [e ]), exclua this.track.timeoutIDs [e])}}, {key: "forceTrackIState", valor: function (e) {this.computeState (). iState! == e && (this.track.mouseOn = "pairar "=== e ||" hoverActive "=== e, this.track.buttonDown =" hoverActive "=== e, this.track.touchDown =" touchActive "=== e, this.track.spaceKeyDown =" keyActive "=== e, this.track.enterKeyDown =" keyActive "=== e,this.track.drag =! 1)}}, {chave: "forceState", valor: function (e) {if (void 0! == e.iState && this.forceTrackIState (e.iState), void 0! == e .focus && e.focus! == this.track.state.focus) retorna this.track.focus = e.focus, anula this.manageFocus (e.focus? "forceStateFocusTrue": "forceStateFocusFalse"); this.updateState (this. computeState (), this.p.props, (0, O.dummyEvent) ("forcestate"))}}, {chave: "computeState", valor: function () {var e = this.track, t = e. mouseOn, n = e.buttonDown, r = e.touchDown, o = e.focus, a = e.drag, i = o && (this.track.enterKeyDown && this.enterKeyTrigger || this.track.spaceKeyDown && this.spaceKeyTrigger), u = {focus: o}; return t || n || r || i || a?! t || n || r || i || a? t && n &&! r &&! i || a &&! r? uEstado = "hoverActive": i &&! r? u.iState = "keyActive" :( r || a) && (u.iState = "touchActive"): u.iState = "pairar": u.iState = "normal", u}}, {chave: "updateState", valor: função (e, t, n, r) {r || Este é um exemplo de um exemplo de um exemplo de código de barras, que é um exemplo de código de barras, que é um código de barras que é usado para armazenar dados em um banco de dados. i || u) {var s = {iState: o, foco: this.track.state.focus}, c = {iState: a, focus: e.focus}; t.onStateChange && t.onStateChange ({prevState: s, nextState: c, evento: n}), this.track.state = e, this.setState (e, t.setStateCallback && t.setStateCallback.bind (este, {prevState: s, nextState: c}))}}}, { chave: "isValidEvent", valor: function (e) {if ("click" === e.type && "reset"! == this.track.clickType) return! 0; if (("focus" === e .type || "blur" === e.type) && e.target! == this.topNode) return! 0; if ("focus" === e.type && "refCallbackFocus" === this.track.focusTransition) retorna e.stopPropagation (), this.track.focusTransition = "reset",! 1; if ("blur" === e.type && "focusForceBlur" === this.track.focusTransition &&! this.track.state .focus) retorne e.stopPropagation (), this.track.focusTransition = "reset",! 1; if (O.deviceHasTouch) {if ("click" === e.type && (C.default.touch.recentTouch | | C.default.touch.touchOnScreen) && (this.p.props.active || this.p.props.touchActive)) retorna e.preventDefault (), e.stopPropagation () ,! 1; if ("focus" === e.type && "reset" === this.track.focusTransition && (C.default.touch.recentTouch ||! this.track.touchDown && C.default.touch.touchOnScreen)) retorna e.preventDefault (), e. stopPropagation (), this.manageFocus ("focusForceBlur") ,! 1} retorne "híbrido"! == O.deviceType ||! /mouse/.test (e.tipo) ||! C.default.touch.touchOnScreen &&! C.default.touch.recentTouch || (e.preventDefault (), e.stopPropagation () ,! 1)}}, {key: "manageNotifyOfNext", valor: função (e) {var t = isso, n = função (e) {t.track.notifyOfNext [e] || (t.track.notifyOfNext [e] = (0, T.notifyOfNext) (e, t.handleNotifyOfNext ))}, r = função (e) {t.track.notifyOfNext [e] && ((0, T.cancelNotifyOfNext) (e, t.track.notifyOfNext [e]), exclua t.track.notifyOfNext [e] )}; if (O.deviceHasMouse) {var o = "normal"! == e.iState &&! this.track.drag; o? n ("mouseenter"): r ("mouseenter"), o? n (" dragstart "): r (" dragstart "), O.passiveEventSupport && (o? n (" scroll "): r (" scroll ")), this.track.mouseOn? n (" mutation "): r (" mutation " )} O.deviceHasTouch && ("touchActive" === e.iState? This.p.props.extraTouchNoTap && n ("touchstart"): r ("touchstart")), this.track.state.focus &&! e.focus && (n ("borrão"), this.manageSetTimeout ("elementBlur", function () {t.track. previousFocus =! 1, r ("desfoque")}, O.queueTime))}}, {chave: "checkMousePosition", valor: função (e) {função t (e) {var t = e.getBoundingClientRect (); return n> = t.left-1 && n <= t.right + 1 && r> = t.top-1 && r <= t.bottom + 1} if (! O.deviceHasMouse) retorna null; var n = e && e.clientX || C .default.mouse.clientX, r = e && e.clientY || C.default.mouse.clientY, o =! 0; retornar o = !! C.default.mouse.mouseOnDocument && (this.p.props.nonContainedChild? (0 , k.default) (this.topNode, t): t (this.topNode)), o? "mouseOn": "mouseOff"}}, {key: "manageFocus", valor: function (e, t) {var n = this; if (t && (w.focusRegistry.foco === t || w.focusRegistry.blur === t)) retorna "updateState"; var r =! O.nonBlurrableTags [this.tagName] &&! this.p.props.focusToggleOff, o = this.p .props.tabIndex || O.knownRoleTags [this.tagName], a = function (e, a, i) {return ("force" === i || "focus" === e & o || "blur" = == e && r) && (t && (w.focusRegistry [e] = t, n.manageSetTimeout ("focusRegistry", função () {w.focusRegistry [e] = null}, 0)), n.track.focusTransition = a , n.topNode [e] (), n.track.focusTransition! == a)? "encerrar" :( n.track.focusTransition = "redefinir", "updateState")}; switch (e) {case "mousedown ": retorna a (" focus "," mouseDownFocus "); case" mouseup ": retorna this.track.focusStateOnMouseDown? a (" blur "," mouseUpBlur ") :( this.track.focusTransition =" reset ","updateState "); case" touchclick ": função de retorno (e, t) {return n.track.state.focus? a (" desfoque ", e +" Blur ", t): a (" foco ", e +" Focus " , t)} ("touchClick"); case "forceStateFocusTrue": retorna this.manageSetTimeout ("forceStateFocusTrue", function () {! n.track.state.focus && a ("focus", "forceStateFocus", "force")} , 0), "terminate"; case "forceStateFocusFalse": retorna this.manageSetTimeout ("forceStateFocusFalse", function () {n.track.state.focus && a ("blur", "forceStateBlur", "force")}, 0) , "terminate"; case "refCallback": retorna this.track.state.focus? a ("focus", "refCallbackFocus", "force") :( this.track.focusTransition = "reset", "terminate");case "focusForceBlur": retorne um ("blur", "focusForceBlur", "force"); padrão: retorne "updateState"}}}, {key: "handleMouseEvent", valor: function (e) {switch (e.type ) {case "mouseenter": return (0, w.updateMouseFromRI) (e), this.p.props.onMouseEnter && this.p.props.onMouseEnter (e), this.track.mouseOn =! 0, this.track.buttonDown = 1 === botões eletrônicos, "updateState"; case "mouseleave": return (0, w.updateMouseFromRI) (e), this.p.props.onMouseLeave && this.p.props.onMouseLeave (e), this.track .mouseOn =! 1, this.track.buttonDown =! 1, "updateState"; case "mousemove": retorna this.p.props.onMouseMove && this.p.props.onMouseMove (e), this.track.mouseOn && this.track. buttonDown === (1 === e.buttons)? "terminate" :( this.track.mouseOn =! 0, this.track.buttonDown = 1 === e.buttons,"updateState"); case "mousedown": retorna this.p.props.onMouseDown && this.p.props.onMouseDown (e), this.track.mouseOn =! 0, this.track.buttonDown =! 0, this.track. focusStateOnMouseDown = this.track.state.focus, this.manageFocus ("mousedown", e); case "mouseup": this.p.props.onMouseUp && this.p.props.onMouseUp (e), this.track.buttonDown =! 1; var t = this.manageFocus ("mouseup", e); retorne this.manageClick ("mouseClick"), t; padrão: retorne "terminate"}}}, {key: "handleTouchEvent", value: function (e ) {var t = this; this.track.mouseOn =! 1, this.track.buttonDown =! 1; var n = function () {t.track.touchDown =! 1, t.track.touches = {pontos: {}, ativo: 0}, t.cancelTimeout ("touchTapTimer")}, r = função () {t.track.recentTouch =! 0, t.manageSetTimeout ("recentTouchTimer", função () {t.track.recentTouch =! 1}, O.queueTime)}, o = function () {retorna tpprops.extraTouchNoTap && e.touches.length! == t.track.touches.active || t.track.touches.active> t.maxTapPoints}, a = function (e, t , n) {return Math.abs (e.clientX-t.startX)> = 15 + 3 * n || Math.abs (e.clientY-t.startY)> = 15 + 3 * n}, i = função (n) {para (var r = 0; r <e.changedTouches.length; r ++) {var o = t.track.touches.points [e.changedTouches [r] .identifier] || {}; o [n + "X"] = e.changedTouches [r] .clienteX, o [n + "Y"] = e.changedTouches [r] .clienteY, t.track.touches.points [e.changedTouches [r] .identifier] = o }}; switch (e.type) {case "touchstart": if (this.p.props.onTouchStart && this.p.props.onTouchStart (e), this.track.touches.active + = e.changedTouches.length, isso. track.touches.tapCanceled) retornar "encerrar"; var u =! this.track.touchDown; retornar this.track.touchDown =! 0, this.track.touches.touchend || o ()? "updateState "=== this.handleTouchEvent ({type:" touchtapcancel "}) || u?" updateState ":" terminate ":( u && (e.persist (), this.manageSetTimeout (" touchTapTimer ", function () { tpprops.onLongPress && t.p.props.onLongPress (e), t.handleEvent ((0, O.dummyEvent) ("touchtapcancel"))}, this.p.props.tapTimeCutoff)), i ("start"), " updateState "); case" touchmove ": if (this.p.props.onTouchMove && this.p.props.onTouchMove (e), this.track.touches.tapCanceled) retorna" terminate "; if (o ()) retorna isso. handleTouchEvent ({type: "touchtapcancel"}); if (this.p.props.touchActiveTapOnly || this.p.props.onLongPress) for (var s = 0; s <e.changedTouches.length; s ++) {var c = this.track.touches.points [e.changedTouches [s] .identifier]; if (c && a (e.changedTouches [s], c, isso.maxTapPoints)) retorne this.handleTouchEvent ({type: "touchtapcancel"})} retorne "terminate"; case "touchend": if (r (), this.p.props.onTouchEnd && this.p.props.onTouchEnd (e), this.track.touches.active- = e.changedTouches.length, this.track.touches.active <0 || 0 === e.touches.length && this.track.touches.active> 0) return n (), " updateState "; if (this.track.touches.touchend =! 0,0 === this.track.touches.active && (this.track.touches.tapCanceled || o ())) retorna n ()," updateState " ; if (this.track.touches.tapCanceled) retorna "terminate"; if (o ()) retorna this.handleTouchEvent ({type: "touchtapcancel"}); if (i ("client"), 0 === .track.touches.active) {var l = this.track.touches.points, p = Object.keys (l), f = p.length, d = p.every (function (e) {return! a (l [e], l [e], f)})? f: 0; switch (n (), d) {caso 1: var h = "updateState "; return (this.p.props.active || this.p.props.touchActive) && (h = this.manageFocus (" touchclick ", e), this.manageClick (" tapClick ")), h; case 2: this.p.props.onTapTwo && this.p.props.onTapTwo (e); break; case 3: this.p.props.onTapThree && this.p.props.onTapThree (e); break; case 4: this.p. props.onTapFour && this.p.props.onTapFour (e)}} retorne "updateState"; case "touchcancel": retorne r (), this.p.props.onTouchCancel && this.p.props.onTouchCancel (e), this.track. touches.active- = e.changedTouches.length, 0 === this.track.touches.active? (n (), "updateState"): this.handleTouchEvent ({type: "touchtapcancel"}); case "touchtapcancel" : retorne this.cancelTimeout ("touchTapTimer"), this.track.touchDown && (this.track.touches.tapCanceled =! 0, this.p.props.touchActiveTapOnly)? (this.track.touchDown =! 1, "updateState"): "encerrar"; padrão: retornar "encerrar"}}}, {key: "manageClick", valor: function (e) {var t = this ; this.cancelTimeout ("clickType"); var n = function () {t.manageSetTimeout ("clickType", function () {t.track.clickType = "reset"}, O.queueTime)}; switch (e) {case "mouseClick": this.track.clickType = "mouseClick", n (); break; case "tapClick": this.track.clickType = "tapClick", (0, P. padrão) (this.topNode), this.track.clickType = "reset"; break; case "keyClick": this.track.clickType = "keyClick", O.knownRoleTags [this.tagName]? n (): this.p.props.onClick && (this. topNode.click (), this.track.clickType = "redefinir")}}}, {key: "handleClickEvent", valor: function (e) {this.cancelTimeout ("clickType "); var t =" encerrar "; retornar" redefinir "=== this.track.clickType && (" input "=== this.tagName &&" submit "=== this.type && C.default.key.recentEnterKeyDown? this .track.clickType = "keyClick": C.default.touch.recentTouch || C.default.touch.touchOnScreen || "touchOnly" === O.deviceType? (t = this.manageFocus ("touchclick", e) , this.track.keyClick = "tapClick"): this.track.keyClick = "mouseClick"), "_ blank"! == this.p.props.target || "tapClick"! == this.track.clickType | | this.track.notifyOfNext.focus || (this.track.previousFocus = "touch", this.track.notifyOfNext.focus = (0, T.notifyOfNext) ("foco", this.handleNotifyOfNext)), this.p .props.onClick && this.p.props.onClick (e, this.track.clickType), this.track.clickType = "reset",t}}, {chave: "handleOtherEvent", valor: function (e) {switch (e.type) {case "focus": if (this.p.props.onFocus && this.p.props.onFocus (e), e .target! == this.topNode) retorna "encerrar"; if ("reset"! == this.track.focusTransition ||! this.track.focus) {var t = this.track.focusTransition.toLowerCase (); /mouse/.test(t)?this.track.focus="mouse":/touch/.test(t)||this.track.touchDown?this.track.focus="touch":this.track.reinstateFocus ? this.track.focus = this.track.previousFocus: /forcestate/.test (t) || (this.track.focus = "tab")} retorna this.cancelTimeout ("windowFocus"), this.track.reinstateFocus =! 1, this.track.focusTransition = "redefinir", "updateState"; case "blur": retorna this.p.props.onBlur && this.p.props.onBlur (e), e.target! == this.topNode ? "encerrar" :( this.track.focusTransition = "redefinir", this.track.previousFocus = this.track.focus, this.track.focus =! 1, this.track.spaceKeyDown =! 1, this.track.enterKeyDown =! 1, "updateState"); case "keydown": if (this.p.props.onKeyDown && this.p.props.onKeyDown (e) ,! this.track.focus) retornará "terminate"; if ("" === e.key) this.track .spaceKeyDown =! 0; else {if ("Enter"! == e.key) retorna "encerrar"; this.track.enterKeyDown =! 0, this.enterKeyTrigger && this.manageClick ("keyClick")} return "updateState"; case "keyup": if (this.p.props.onKeyUp && this.p.props.onKeyUp (e) ,! this.track.focus) retorna "terminate"; if ("Enter" === e.key) this. track.enterKeyDown =! 1; else {if (""! == e.key) retorna "terminate"; this.track.spaceKeyDown =! 1, this.spaceKeyTrigger && this.manageClick ("keyClick")} retorne "updateState"; case "dragstart": retorne this.p.props.onDragStart && this.p.props.onDragStart (e), this.track.drag =! 0, "updateState"; case " dragend ": retorna this.p.props.onDragEnd && this.p.props.onDragEnd (e), this.forceTrackIState (" normal ")," updateState "; padrão: retorna" terminate "}}}, {key:" computeStyle " , value: function () {var e = {}; this.p.props.useBrowserOutlineFocus ||! this.p.props.focusFromTab && ("tab" === this.state.focus || O.nonBlurrableTags [this. tagName]) || (e.outline = 0, e.outlineOffset = 0), (this.p.props.touchActive || this.p.props.active) && O.deviceHasTouch && (e.WebkitTapHighlightColor = "rgba (0, 0, 0, 0) "); var t =" string "== tipo deste.p.props.as && this.p.props.as.toLowerCase ();this.p.props.useBrowserCursor ||! (this.p.props.onClick || "input"! == && this.p.props.tabIndex && (this.p.mouseFocusStyle.style || this.p.mouseFocusStyle.className ) || "input" === t&& ("caixa de seleção" === this.p.props.type || "radio" === this.p.props.type || "submit" === this.p .props.type) || "button" === t || "a" === t || "area" === t || "select" === t) || this.p.props. desativado || (e.cursor = "ponteiro"), (0, defeito padrão) (e, this.p.props.style); var n = "keyActive" === this.state.iState || this. p.props.stylePriority && this.p.props.stylePriority [this.state.iState], r = this.p [this.state.iState + "Style"]. style, o = this.state.focus? this.p [this .state.focus + "FocusStyle"]. style: null; return n? (0, defeito padrão) (e, o, r) :( 0, defeito padrão) (e, r, o), e}}, {chave:"computeClassName ", valor: function () {return (0, g.joinClasses) (this.p.props.className ||" ", this.p [this.state.iState +" Style "]. className, this.state. foco? this.p [this.state.focus + "FocusStyle"]. className: "")}}, {key: "computeChildren", valor: function () {var e = this, n = this.state.focus && " focusFrom "+ this.state.focus.charAt (0) .toUpperCase () + this.state.focus.slice (1), r = this.p.props.stylePriority && this.p.props.stylePriority [this.state.iState ], o = função (t) {var o = t.style? u ({}, t.style): {}; (0, g.setActiveAndFocusProps) (t); var a = (0, g.extractStyle) (t, e.state.iState), i = e.state.focus && (0, g.extractStyle) (t, n); return {className: (0, g.joinClasses) (t.className || "", a.className, i && i.className || ""), estilo: r && (0, padrão de falta) (o, estilo, estilo de moda) || (0, padrão) (o, a.style, i.style)}}; return function r (a) {return l.default.Children.map (a, function (a) {if (! l.default.isValidElement (a)) retorna a; if (a .props.showOnParent &&! a.props.showOnParent.split ("") .alguns (função (t) {return t === e.state.iState || /Active/.test (e.state.iState) && " ativo "=== t || e.state.focus && (t === n ||" foco "=== t)})) retorna nulo; var i = Object.keys (a.props); if (! i.some (function (e) {return O.childInteractiveProps [e]})) retorna a.type === t? a: l.default.cloneElement (a, {}, r (a.props.children)) ; var u = {}, s = {}; i.forEach (function (e) {O.childInteractiveProps [e]? "showOnParent"! == e && (s ["" + e.slice (8) .charAt ( 0) .toLowerCase () + e.slice (9)] = a.props [e]): u [e] = a.props [e]}), s.style = a.props.style, s.className = a.props.className; var c = o (s), p = c.style, f = c.className; retorna u.style = p, f && (u.className = f), l.default.createElement (a.type, u, a.type === t? a.props.children: r (a.props.children))})} (this.p.props.children)}}, {key : "render", value: function () {this.p.passThroughProps.style = this.computeStyle (); var e = this.computeClassName (); e && (this.p.passThroughProps.className = e); var t = this.p.props.interactiveChild? this.computeChildren (): this.p.props.children; return "string" == type of this.p.props.as?(this.p.passThroughProps.ref=this.refCallback, l.default.createElement (this.p.props.as, this.p.passThroughProps, t)): l.default.createElement ("extensão", {ref: this.refCallback, estilo: this.p.props.wrapperStyle , className: this.p.props.wrapperClassName}, l.default.createElement (this.p.props.as, this.p.passThroughProps, t))}}]), t} (l.default.Component); S.propTypes = d.propTypes, S.defaultProps = d.defaultProps, t.default = S, e.exports = t.default}, função (e, t,n) {"use strict"; var r = função (e, t, n, r, o, a, i, u) {if (! e) {var s; if (void 0 === t) s = new Error ("Ocorreu uma exceção minimizada; use o ambiente de desenvolvimento não minificado para obter a mensagem de erro completa e outros avisos úteis."); else {var c = [n, r, o, a, i, u], l = 0 ; s = novo erro (t.replace (/% s / g, function () {return c [l ++]})), s.name = "Violação invariável"} lança s.framesToPop = 1, s}}; e .exports = r}, função (e, t, n) {"use strict"; nd (t, "a", function () {return u}), nd (t, "b", function () {return s}); var r = n (20), o = n (21), a = n (8), i = Object.assign || função (e) {for (var t = 1; t <argument.length ; t ++) {var n = argumentos [t]; para (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retorne e}, u = função (e, t, n, o) {var u = 0 vazio; "string" == tipo de e? (u = objeto (ad) (e), u.state = t) :( u = i ({} , e), void 0 === u.pathname && (u.nome do caminho = ""), u.search?"?"!==u.search.charAt(0)&&(u.search="?"+u.search):u.search=""u.hash? "#"! == u.hash.charAt (0) && (u.hash = "#" + u.hash): u.hash = "", nulo 0! == t && void 0 === u.state && ( u.state = t)); try {u.pathname = decodeURI (u.pathname)} catch (e) {throw a instance of URIError? new URIError ('Nome do caminho "' + u.nome do caminho + '" não pôde ser decodificado. provavelmente é causado por uma codificação de porcentagem inválida. '): e} retorne n && (u.key = n), o? u.pathname? "/"! == u.pathname.charAt (0) && (u.pathname = Objeto (r.default) (u.pathname, o.pathname)): u.pathname = o.pathname: u.pathname || (u.pathname = "/"), u}, s = function (e, t) {return e.pathname === t.pathname && e.search === t.search && e.hash === t.hash && e.key === t.key && Object (o.padrão) (e.state, t.state)}}, function (e, t, n) {"use strict"; function r (e) {return e && e .__ esModule? e: {padrão: e}} t .__ esModule =! 0, t.locationsAreEqual = t.createLocation = void 0; var o = Object.assign || função (e) {para (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t ]; para (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retornar e}, a = n (20), i = r (a ), u = n (21), s = r (u), c = n (7); t.createLocation = function (e, t, n, r) {var a = void 0; "string" == typeof e? (a = (0, c.parsePath) (e), a.state = t) :( a = o ({}, e), nulo 0 === a.pathname && (a.pathname = "") , a.search? "?"! == a.search.charAt (0) && (a.search = "?" + a.search): a.search = "", a.hash? "#"! = = a.hash.charAt (0) && (a.hash = "#" + a.hash): a.hash = "", nulo 0! == t && nulo 0 === a.estado && (a.state = t )); tente {a.nome do caminho = decodeURI (a.pathname)} catch (e) {throw the instance of URIError? new URIError ('Nome do caminho "' + a.nome do caminho + '" não pôde ser decodificado. Isso provavelmente é causado por uma porcentagem de codificação inválida.') : e} retornar n && (a.key = n), r? a.pathname? "/"! == a.pathname.charAt (0) && (a.pathname = (0, i.default) (a.pathname , r.pathname)): a.pathname = r.pathname: a.pathname || (a.pathname = "/"), a}, t.locationsAreEqual = function (e, t) {return e.pathname == = t.pathname && e.search === t.search && e.hash === t.hash && e.key === t.key && (0, s.default) (e.state, t.state)}}, function (e , t, n) {"use strict"; t .__ esModule =! 0; var r = n (2), o = function (e) {return e && e .__ esModule? e: {padrão: e}} (r), a = function () {var e = null, t = function (t) {return (0, o.default) (null == e, "Um histórico suporta apenas um prompt por vez"), e = t,função () {e === t && (e = nulo)}}, n = função (t, n, r, a) {se (nulo! = e) {var i = "função" == tipo de e? e (t, n): e; "string" == tipo de i? "função" == tipo de r? r (i, a): ((0, o.default) (! 1, "Um histórico precisa de uma função getUserConfirmation para usar uma mensagem de prompt "), a (! 0)): a (! 1! == i)} mais a (! 0)}, r = []; return {setPrompt: t, confirmTransitionTo: n, appendListener: function (e) {var t =! 0, n = function () {t && e.apply (void 0, argumentos)}; retorna r.push (n), function () {t =! 1, r = r .filter (função (e) {return e! == n})}}, notifyListeners: function () {for (var e = argument.length, t = Array (e), n = 0; n <e; n ++ ) t [n] = argumentos [n]; r.forEach (function (e) {return e.apply (void 0, t)})}}}; t.default = a}, function (e, t, n ) {"use strict"; var r = n (15); ta = ra}, função (e, t, n) {"use strict"; função r (e, t) {if (! (instância de t) ) lança novo TypeError ("Não é possível chamar uma classe como uma função ")} função o (e, t) {se (! E) lança novo ReferenceError (" isso não foi inicializado - super () não foi chamado "); return! T | | "object"! = typeof t && "function"! = typeof t? e: t} função a (e, t) {if ("function"! = typeof t && null! == t) lança novo TypeError ("Super expressão deve seja nulo ou uma função, não "+ typeof t); e.prototype = Object.create (t && t.prototype, {construtor: {value: e, enumerable:! 1, gravável:! 0, configurável:! 0}} ), t && (Object.setPrototypeOf? Object.setPrototypeOf (e, t): e .__ proto __ = t)} var i = n (2), u = nn (i), s = n (6), c = nn ( s), l = n (0), p = nn (l), f = n (1), d = nn (f), h = Object.assign || função (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} return e}m = função (e) {função t () {var n, a, i; r (isto, t); para (var u = argumentos. comprimento, s = Matriz (u), c = 0; c <u; c ++) s [c] = argumentos [c]; retorno n = a = o (este, e.call.apply (e, [este] .concat (s))), a.state = {match: a.computeMatch (a.props.history.location.pathname)}, i = n, o (a, i)} retorna a (t, e), t.prototype.getChildContext = function () {return {router: h ({} , this.context.router, {history: this.props.history, route: {location: this.props.history.location, match: this.state.match}})}}, t.prototype.computeMatch = function ( e) {retornar {caminho: "/", url: "/", parâmetros: {}, isExact: "/" === e}}, t.prototype.componentWillMount = function () {var e = this, t = this.props, n = t.children, r = t.history; c () (null == n || 1 === paChildren.count (n), "Um <Router> pode ter apenas um elemento filho" ), this.unlisten = r.listen (function () {e.setState ({match: e.computeMatch (r.location.pathname)})})}), t.prototype.componentWillReceiveProps = function (e) {u () (this.props.history === e.history, "Você não pode alterar <Histórico do roteador>")}, t.prototype.componentWillUnmount = function () {this.unlisten () } t.prototype.render = function () {var e = this.props.children; return e? paChildren.only (e): null}, t} (paComponent); m.propTypes = {history: daobject.isRequired , filhos: danode}, m.contextTypes = {roteador: daobject}, m.childContextTypes = {roteador: daobject.isRequired}, ta = m}, função (e, t, n) {"use strict"; var r = n (60), o = nn (r), a = {}, i = 0, u = função (e, t) {var n = "" + t.end + t.strict + t.sensitive, r = a [n] || (a [n] = {}); se (r [e]) retorna r [e]; var u = [], s = o () (e, u, t), c = {re: s, keys: u}; retorna i <1e4 && (r [e] = c, i ++), c}, s = função (e) {var t = argument.length> 1 && void 0! == argumentos [1 ]? argumentos [1]: {}; "string" == tipo de t && (t = {caminho: t}); var n = t, r = n.caminho,o = void 0 === r? "/": r, a = n.exact, i = void 0! == a && a, s = n.strict, c = void 0! == s && s, l = n.sensitive , p = void 0! == l &&l, f = u (o, {fim: i, estrito: c, sensível: p}), d = f.re, h = f.keys, m = d.exec (e ); se (! m) retornar nulo; var y = m [0], v = m.slice (1), g = e === y; retornar i &&! g? null: {caminho: o, url: " /"===o&&""===y?"/":y,isExato:g,params:h.reduce(function(e,t,n){return e [t.name] = v [n] , e}, {})}}; ta = s}, função (e, t, n) {"use strict"; var r = n (2), o = nn (r), a = function () { var e = nulo, t = função (t) {retorna o () (nulo == e, "Um histórico suporta apenas um prompt de cada vez"), e = t, função () {e === t && (e = null)}}, n = function (t, n, r, a) {if (null! = e) {vari = "function" == tipo de e? e (t, n): e; "string" == typeof i? "function" == typeof r? r (i, a) :( o () (! 1, "Um histórico precisa de uma função getUserConfirmation para usar uma mensagem de prompt "), a (! 0)): a (! 1! == i)} mais a (! 0)}, r = []; return {setPrompt: t, confirmTransitionTo: n, appendListener: function (e) {var t =! 0, n = function () {t && e.apply (void 0, argumentos)}; return r.push (n), function () {t = ! 1, r = filtro.filtro (função (e) {retorne e! == n})}}, notifyListeners: function () {para (var e = argumentos.comprimento, t = matriz (e), n = 0 ; n <e; n ++) t [n] = argumentos [n]; r.forEach (function (e) {return e.apply (void 0, t)})}}}; ta = a}, função (e , t, n) {"use strict"; função r (e) {return m === Number.MAX_SAFE_INTEGER && (m = 0), m ++, void 0 === h [e] [m]? m: r ( e)} função o (e, t) {var n = r (e); retorna h [e] [n] = d [e]. push ({id: n, retorno de chamada: t}) - 1, n} função a (e, t) {"indefinido"! == h [e] [t] && (d [e] [h [e] [t]]. retorno de chamada = y, exclua h [e] [t]) } função i (e, t) {e.paraCada (função (e) {f [e] = t})} função u (e) {f [e.tipo] (e)} função s (e) {if (0! == d [e.type] .length) {e.persist = y; var t = [], n = {}; d [e.type ] .forEach (function (r) {"reNotifyOfNext" === r.callback (e) && (n [r.id] = t.push (r) -1)}), d [e.type] = t , h [e.type] = n}} função c (e) {u (e), s (e)} função l (e, t, n, r) {d [t] = [], h [t ] = {}, e.addEventListener (t, n, p.passiveEventSupport? {capture: r, passivo: "clique"! == t}: r)} Object.defineProperty (t, "__ esModule", {value :! 0}), t.notifyOfNext = o, t.cancelNotifyOfNext = a, t.notifyOfAll = i; var p = n (4), f = {}, d = {}, h = {}, m = 0, y = function () {}; if (p.deviceHasTouch && (l (window, "click", u,! 0), Object.keys (p.touchEvents) .forEach (function (e) {l (document, e, " touchstart "=== e? c: u,! 0)})), p.deviceHasMouse) {Object.keys (p.mouseEvents) .forEach (function (e) {l (documento, e," mouseenter "== = e? c: u,! ("mouseenter" === e || "ratoeira" === e))}), l (documento,"dragstart", s,! 0), p.passiveEventSupport && l (documento, "scroll", s,! 0), d.mutation = [], h.mutation = {}; var v = (0, p.dummyEvent) ("mutation"); new MutationObserver (s.bind (null, v)). observe (documento, {childList:! 0, atributos:! 0, subárvore:! 0, characterData:! 0})} ["focus" , "blur"]. forEach (função (e) {l (janela, e, s,! 1)}), l (documento, "keydown", u,! 0)}, função (e, t, n) {"use strict"; função r (e) {função de retorno () {return e}} var o = function () {}; o.thatReturns = r, o.thatReturnsFalse = r (! 1), o.thatReturnsTrue = r (! 0), o.thatReturnsNull = r (null), o.thatReturnsThis = function () {retorna isso}, o.thatReturnsArgument = function (e) {return e}, e.exports = o}, function (e , t, n) {"use strict"; função r (e) {return "/" === e.charAt (0)} função o (e, t) {for (var n = t, r = n + 1, o = comprimento e; r <o; n + = 1, r + = 1) e [n] = e [r]; e.função pop ()} a (e) {var t = argument.length> 1 && void 0! == argumentos [1]? argumentos [1]: "", n = e && e.split ("/") || [], a = t && t.split ("/") || [], i = e && r (e), u = t && r (t), s = i || u; se (e && r (e)? a = n: n.length && (a.pop (), a = a.concat (n)) ,! a.length) return "/"; var c = void 0; if (a.length) {var l = a [a.length-1 ]; c = "." === l || ".." === l || "" === l} else c =! 1; para (var p = 0, f = a.length; f > = 0; f -) {var d = a [f]; "." === d? O (a, f): ".." === d? (O (a, f), p ++ ): p && (o (a, f), p -)} if (! s) para (; p -; p) a.shift ("..") ;! s || "" === a [0] || a [0] && r (a [0]) || a.unshift (""); var h = a.join ("/"); retorno c && "/"! == h.substr ( -1) && (h + = "/"), h} Object.defineProperty (t, "__ esModule", {valor:! 0}), t.default = a},function (e, t, n) {"use strict"; function r (e, t) {if (e === t) retorna! 0; if (null == e || null == t) retorna! 1 ; if (Array.isArray (e)) retorna Array.isArray (t) && e.length === t.length && e.every (function (e, n) {return r (e, t [n])}); var n = void 0 === e? "indefinido": o (e); if (n! == (void 0 === t? "indefinido": o (t))) return! 1; if ("objeto "=== n) {var a = e.valorOf (), i = t.valorOf (); if (a! == e || i! == t) retorna r (a, i); var u = Object.keys (e), s = Object.keys (t); return u.length === s.length && u.every (function (n) {return r (e [n], t [n])})} return! 1} Object.defineProperty (t, "__ esModule", {value:! 0}); var o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator? function (e) {return typeof e }: function (e) {return e && "function" == tipo de Symbol && e.constructor === Symbol && e! == Symbol.prototype? "símbolo ": typeof e}; t.default = r}, função (e, t, n) {" use strict "; t .__ esModule =! 0, t.canUseDOM =! (" undefined "== typeof window || ! window.document ||! window.document.createElement), t.addEventListener = função (e, t, n) {retorna e.addEventListener? e.addEventListener (t, n,! 1): e.attachEvent ("em "+ t, n)}, t.removeEventListener = função (e, t, n) {retornar e.removeEventListener? e.removeEventListener (t, n,! 1): e.detachEvent (" em "+ t, n) } t.getConfirmation = function (e, t) {return t (window.confirm (e))}, t.supportsHistory = function () {var e = window.navigator.userAgent; return (-1 === e .indexOf ("Android 2.") && - 1 === e.indexOf ("Android 4.0") || -1 === e.indexOf ("Mobile Safari") || -1! == e.indexOf ("Chrome") || -1! == e.indexOf ("Windows Phone")) && window.history && "pushState" na janela.histórico}, t.supportsPopStateOnHashChange = function () {return-1 === window.navigator.userAgent.indexOf ("Trident")}, t.supportsGoWithoutReloadUsingHash = function () {return-1 === window.navigator.userAgent .indexOf ("Firefox")}, t.isExtraneousPopstateEvent = function (e) {return void 0 === e.state && - 1 === navigator.userAgent.indexOf ("CriOS")}}, function (e, t , n) {"use strict"; função r (e, t) {var n = {}; para (var r em e) t.indexOf (r)> = 0 || Object.prototype.hasOwnProperty.call (e , r) && (n [r] = e [r]); retorna n} função o (e, t) {if (! (instância de t)) lança novo TypeError ("Não é possível chamar uma classe como uma função") } função a (e, t) {if (! e) lança um novo ReferenceError ("isso não foi inicializado - super () não foi chamado"); return! t || "object"! = typeof t && " função "! = tipo de t? e: t} função i (e,t) {if ("function"! = typeof t && null! == t) lança novo TypeError ("A super expressão deve ser nula ou uma função, não" + typeof t); e.prototype = Object.create (t && t.prototype , {construtor: {valor: e, enumerável:! 1, gravável:! 0, configurável:! 0}}), t && (Object.setPrototypeOf? Object.setPrototypeOf (e, t): e .__ proto __ = t)} var u = n (0), s = nn (u), c = n (1), l = nn (c), p = n (55), f = nn (p), d = função Object.assign || (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retorne e}, h = função (e) {retorne !! (chave.meta || e.altKey || chave e.ctrl || chave e.shift)}, m = função ( e) {função t () {var n, r, i; o (isto, t); para (var u = argumentos.length, s = Matriz (u), c = 0; c <u; c ++) s [ c] = argumentos [c]; retorno n = r = a (isso, chamada.aplicação (e, [isso] .concat (s))), r.handleClick = função (e) {if (r.props .onClick && r.props.onClick (e) ,! e.defaultPrevented && 0 === botão e &!! r.props.target &&! h (e)) {e.preventDefault (); var t = r.context.router.history, n = r.props, o = n.replace, a = n.to; o? t.replace (a): t.push (a)}}, i = n, a (r, i)} return i (t , e), t.prototype.render = function () {var e = this.props, t = (e.replace, e.to), n = e.innerRef, o = r (e, "substituir", "to", "innerRef"]); f () (this.context.router, "Você não deve usar <Link> fora de um <Router>"); var a = this.context.router.history.createHref (" string "== tipo de t? {nome do caminho: t}: t); retornar sacreateElement (" a ", d ({}, o, {onClick: this.handleClick, href: a, ref: n}))}, t } (saComponent); m.propTypes = {onClick: lafunc, target: lastring, substitua: labool, por: laoneOfType ([lastring, laobject]). isRequired, innerRef: laoneOfType ([lastring, lafunc])}, m.defaultProps = {substituir:! 1}, m.contextTypes = {roteador: lashape ({histórico: lashape ({push: lafunc.isRequired, substituir: lafunc.isRequired, createHref: lafunc.isRequired}). isRequired}). isRequired}). isRequired} , ta = m}, função (e, t, n) {"use strict"; var r = n (25); ta = ra}, função (e, t, n) {"use strict"; função r ( e, t) {if (! (instância de t)) lança novo TypeError ("Não é possível chamar uma classe como uma função")} função o (e, t) {if (! e) lança novo ReferenceError ("isso não tem" t foi inicializado - super () não foi chamado "); return! t ||" objeto "! = tipo de t &&" função "! = tipo de t? e: t} função a (e, t) {if (" função "! = typeof t && null! == t) lança novo TypeError (" A super expressão deve ser nula ou uma função, não "+ typeof t); e.prototype = Object.create (t && t.prototype, {constructor: {value : e, enumerável :!1, gravável:! 0, configurável:! 0}}), t && (Object.setPrototypeOf? Object.setPrototypeOf (e, t): e .__ proto __ = t)} var i = n (2), u = nn (i ), s = n (6), c = nn (s), l = n (0), p = nn (l), f = n (1), d = nn (f), h = n (16) , m = Função Object.assign || (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty. chamar (n, r) && (e [r] = n [r])} retornar e}, y = função (e) {retornar 0 === paChildren.count (e)}, v = função (e) { função t () {var n, a, i; r (isto, t); para (var u = argumentos.length, s = Matriz (u), c = 0; c <u; c ++) s [c] = argumentos [c]; return n = a = o (this, e.call.apply (e, [this] .concat (s))), a.state = {match: a.computeMatch (a.props, a. context.router)}, i = n, o (a, i)} retorna a (t, e), t.prototype.getChildContext = function () {return {roteador: m ({}, this.context.router, {route: {location: this.props.location || this.context.router.route.location, match: this.state.match}})}}, t.prototype.computeMatch = function (e, t) {var n = e.computedMatch, r = e.location, o = e.path, a = e.strict, i = e.exact, u = e.sensitive; if (n) return n; c () (t, "Você não deve usar <Route> ou withRouter () fora de um <Router>"); var s = t.route, l = (r || local.local) .pathname; return Objeto (ha) (l, {caminho: o, estrito: a, exato: i, sensível: u}): s.match}, t.prototype.componentWillMount = function () {u () (! (this .props.component && this.props.render), "Você não deve usar <Componente de rota> e <Renderização de rota> na mesma rota; <Renderização de rota> será ignorada"), u () (! (this.props.component && this .props.children &&! y (this.props.children)), "Você não deve usar <Componente de rota> e <Filhos de rota> na mesma rota; <filhos de rota> serão ignorados"), u () (! ( this.props.render && this.props.children &&! y (isso.props.children)), "Você não deve usar <Rota render> e <Rota filhos> na mesma rota; <Rota filhos> serão ignorados")}, t.prototype.componentWillReceiveProps = function (e, t) {u () (! (e.location &&! this.props.location), '<Route> os elementos não devem mudar de descontrolados para controlados (ou vice-versa). Você inicialmente não usou nenhum suporte de "local" e forneceu um em uma renderização subsequente . '), u () (! (! e.location && this.props.location),' <Route> os elementos não devem mudar de controlados para não controlados (ou vice-versa). Você forneceu um suporte de "local" inicialmente, mas o omitiu em uma renderização subsequente. '), this.setState ({match: this.computeMatch (e, t.router)})}, t.prototype.render = function () {var e = this.state.match, t = this .props, n = t.children, r = t.component, o = t.render, a = this.context.router, i = a.history, u = a.route, s = a.staticContext, c = this.props.location || u.location, l = {correspondência: e, localização: c, history: i, staticContext: s}; return r? e? pacreateElement (r, l): null: o? e? o (l): null: n? "function" == tipo de n? n (l): y (n)? null: paChildren.only (n): null}, t} (paComponent); v.propTypes = {computedMatch: daobject, caminho: dastring, exato: dabool, strict: dabool, sensitive: dabool, component: dafunc, render: dafunc , filhos: daoneOfType ([dafunc, danode]), local: daobject}, v.contextTypes = {roteador: dashape ({history: daobject.isRequired, rota: daobject.isRequired, staticContext: daobject})}, v.childContextTypes = {roteador: daobject.isRequired}, ta = v}, função (e, t, n) {"use strict"; nd (t, "b", função () {return r}), nd (t ", a ", function () {return o}), nd (t," e ", function () {return a}), nd (t," c ",function () {return i}), nd (t, "g", function () {return u}), nd (t, "h", função () {return s}), nd (t, "f" , function () {return c}), nd (t, "d", function () {return l}); var r =! ("undefined" == tipo de janela ||! window.document ||! window. document.createElement), o = function (e, t, n) {return e.addEventListener? e.addEventListener (t, n,! 1): e.attachEvent ("em" + t, n)}, a = function (e, t, n) {retornar e.removeEventListener? e.removeEventListener (t, n,! 1): e.detachEvent ("ligado" + t, n)}, i = função (e, t) {retornar t (window.confirm (e))}, u = function () {var e = window.navigator.userAgent; return (-1 === e.indexOf ("Android 2.") && - 1 === e. indexOf ("Android 4.0") || -1 === e.indexOf ("Mobile Safari") || -1! == e.indexOf ("Chrome") || -1! == e.indexOf (" Windows Phone ")) && window.history &&"pushState "em window.history}, s = function () {return-1 === window.navigator.userAgent.indexOf (" Trident ")}, c = function () {return-1 === window.navigator. userAgent.indexOf ("Firefox")}, l = function (e) {return void 0 === e.state && - 1 === navigator.userAgent.indexOf ("CriOS")}}, function (e, t, n) {"use strict"; função r (e) {return e&& .__ esModule? e: {padrão: e}} função o (e) {var t = e.location; return i.default.createElement ("p" , {style: p.default.p}, "Página não encontrada - o caminho", i.default.createElement (c.Code, null, t.pathname), ", não corresponde a nenhuma rota do React Router.") } Object.defineProperty (t, "__ esModule", {value:! 0}), t.default = o; var a = n (0), i = r (a), u = n (1), s = r (u), c = n (3), l = n (97), p = r (l), f = {local: s.default.object.isRequired}; o.propTypes = f}, função (e, t, n) {"use strict";função r (e) {return e && e .__ esModule? e: {padrão: e}} var o = n (0), a = r (o), i = n (34), u = r (i), s = n (5), c = n (78), l = r (c); u.default.render (a.default.createElement (s.BrowserRouter, null, a.default.createElement (l.default, null)) , document.getElementById ("root"))}, função (e, t, n) {"use strict"; função r (e) {for (var t = argument.length-1, n = "Erro de reação minimizada # "+ e +"; visite http://facebook.github.io/react/docs/error-decoder.html?invariant="+e,r=0;r<t;r++)n+="&args[[= " + encodeURIComponent (argumentos [r + 1]); throw t = Error (n + "para a mensagem completa ou use o ambiente de desenvolvimento não minificado para erros completos e avisos úteis adicionais."), t.name = "Violação invariável", t.framesToPop = 1, t} função o (e, t, n) {this.props = e, this.context = t, this.refs = g, this.updater = n || k} função a (e, t, n) {this.props = e, isto.context = t, this.refs = g, this.updater = n || k} função i () {} função u (e, t, n) {this.props = e, this.context = t, this.refs = g, this.updater = n || k} função s (e, t, n, r, o, a, i) {return {$$ typeof: O, tipo: e, key: t, ref: n, props: i, proprietário: a}} função c (e) {var t = {"=": "= 0", ":": "= 2"}; retorne "$" + ("" + e). substituir (/ [=:] / g, função (e) {retornar t [e]})} função l (e, t, n, r) {se (comprimento de M.) {var o = M.pop () ; return o.result = e, o.keyPrefix = t, o.func = n, o.context = r, o.count = 0, o} return {resultado: e, keyPrefix: t, func: n, contexto: r, count: 0}} função p (e) {e.result = nulo, e.keyPrefix = nulo, e.func = nulo, e.context = nulo, e.count = 0,10> M.length && M.push (e)} função f (e, t, n, o) {var a = tipo de e; if ("indefinido"! == a && "booleano"! == a || (e = nulo), nulo === e || "string" === a || "número" === a || "objeto" === a && e.$$ typeof === _) return n (o, e, "" === t? "." + d (e, 0): t), 1; var i = 0; if (t = "" = == t? ".": t + ":", Array.isArray (e)) para (var u = 0; u <comprimento.de; u ++) {a = e [u]; var s = t + d ( a, u); i + = f (a, s, n, o)} else if ("function" == typeof (s = x && e [x] || e ["@@ iterator"])) para (e = () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) n, o); else "objeto" === a && (n = "" + e, r ("31", "[objeto Objeto]" === n? "objeto com chaves {" + Object.keys (e ) .join (",") + "}": n, "")); return i} função d (e, t) {return "object" == tipo de e && null! == e && null! = e.key? c (e.key): t.toString (36)} função h (e, t) {e.func.call (e.context, t, e.count ++)} função m (e, t, n) {var r = e.result, o = e.keyPrefix; e = e.func.call (e.context, t, e.count ++), Array.isArray (e)? y (e, r, n, b.thatReturnsArgument): null! = e && (s.isValidElement (e) && (e = s.cloneAndReplaceKey (e, o + (! e.key || t && t.key === e.key? "): e + .key) .replace (N, "$ & /") + "/") + n)), r.push (e))} função y (e, t, n, r, o) {var a = " "; null! = n && (a = (" "+ n). substitua (N," $ & / ") +" / "), t = l (t, a, r, o), nulo == e | | f (e, "", m, t), p (t)} var v = n (30), g = n (31); n (32); var b = n (33), k = {isMounted : function () {return! 1}, enqueueForceUpdate: function () {}, enqueueReplaceState: function () {}, enqueueSetState: function () {}}; o.prototype.isReactComponent = {}, o.prototype.setState = função (e, t) {"objeto"! = tipo de e && "função"! = tipo de e && null! = e & r ("85"), this.updater.enqueueSetState (this, e, t, "setState")}, o. prototype.forceUpdate = função (e) {this.updater.enqueueForceUpdate (this, e, "forceUpdate")}, i.prototype = o.prototype; var w = a.prototype = new i; w.constructor = a, v (w, o.prototype), w.isPureReactComponent =! 0; var C = u.protótipo = novo i; C. construtor = u, v (C, o.prototype), C.unstable_isAsyncReactComponent =! 0, C.render = function () {retorna this.props.children}; var T = {Componente: o, PureComponent: a, AsyncComponent: u}, E = {current: null}, P = Object.prototype.hasOwnProperty, O = "function" == typeof Symbol && Symbol.for && Symbol.for ("reaja. elemento ") || 60103, S = {chave:! 0, ref:! 0, __ auto:! 0, __ fonte:! 0}; s.createElement = função (e, t, n) {var r, o = { }, a = nulo, i = nulo, u = nulo, c = nulo; se (nulo! = t) para (r no vazio 0! == t.ref && (i = t.ref), vazio 0! == t.key && (a = "" + t.key), u = nulo 0 === t .__ auto? nulo: t .__ auto, c = nulo 0 === t .__ fonte? nulo: t .__ fonte, t) P.call (t, r) && S.hasOwnProperty (r) &&(o [r] = t [r]); var l = argumentos.length-2; if (1 === l) o.children = n; caso contrário, se (1 <l) {for (var p = Array ( l), f = 0; f <l; f ++) p [f] = argumentos [f + 2]; o.children = p} if (e && e.defaultProps) para (r em l = e.defaultProps) void 0 = == o [r] && (o [r] = l [r]); return s (e, a, i, u, c, E.corrente, o)}, s.createFactory = function (e) {var t = s.createElement.bind (null, e); return t.type = e, t}, s.cloneAndReplaceKey = function (e, t) {return s (e.type, t, e.ref, e._self , e._source, e._owner, e.props)}, s.cloneElement = function (e, t, n) {var r = v ({}, e.props), o = e.key, a = e .ref, i = e._self, u = e._source, c = e._owner; if (null! = t) {if (void 0! == t.ref && (a = t.ref, c = E. atual), void 0! == t.key && (o = "" + t.key), e.type && e.type.defaultProps) var l = e.type.defaultProps; para (p em t) P.call (t , p) &&! S.hasOwnProperty (p) && (r [p] = vazio 0 === t [p] && vazio 0! == l? l [p]: t [p])} var p = argumentos. comprimento-2;if (1 === p) r.children = n; else if (1 <p) {l = Matriz (p); for (var f = 0; f <p; f ++) l [f] = argumentos [f +2]; r.children = l} retorna s (e.type, o, a, i, u, c, r)}, s.isValidElement = function (e) {return "objeto" == tipo de e && null! = = e && e. $$ typeof === O}; var x = "function" == typeof Symbol && Symbol.iterator, _ = "function" == typeof Symbol && Symbol.for && Symbol.for ("react.element") || 60103, N = / \ / + / g, M = [], R = {forEach: function (e, t, n) {if (null == e) retorna e; t = l (null, null, t, n), null == e || f (e, "", h, t), p (t)}, map: function (e, t, n) {if (null == e) retorna e; var r = [] ; return y (e, r, nulo, t, n), r}, count: function (e) {return null == e? 0: f (e, "", b.thatReturnsNull, null)}, paraArray: função (e) {var t = []; retorno y (e, t, nulo, b.thatReturnsArgument), t}}; e.exports = {Filhos: {map: R.map, forEach: R.forEach, count : R.count, toArray: R.toArray, apenas:função (e) {retorno s.isValidElement (e) || r ("143"), e}}, Componente: T.Component, PureComponent: T.PureComponent, unstable_AsyncComponent: T.AsyncComponent, createElement: s.createElement, cloneElement : s.cloneElement, isValidElement: s.isValidElement, createFactory: s.createFactory, versão: "16.0.0", __ SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {ReactCurrentOwner: E, atribua: v}}, função (e, t), strict "; função r (e) {if (null === e || void 0 === e) lança novo TypeError (" Object.assign não pode ser chamado com nulo ou indefinido "); return Object (e)} var o = Object.getOwnPropertySymbols, a = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable; e.exports = function () {try {if (! Object.assign) return! 1; var e = new String (" abc "); if (e [5] =" de "," 5 "=== Object.getOwnPropertyNames (e) [0]) return! 1; for (var t = {},n = 0; n <10; n ++) t ["_" + String.fromCharCode (n)] = n; if ("0123456789"! == Object.getOwnPropertyNames (t) .map (função (e) {return t [e]}). join ("")) return! 1; var r = {}; return "abcdefghijklmnopqrst" .split (""). forEach (função (e) {r [e] = e}), " abcdefghijklmnopqrst "=== Object.keys (Object.assign ({}, r)). join (" ")} catch (e) {return! 1}} ()? Object.assign: function (e, t) { for (var n, u, s = r (e), c = 1; c <argument.length; c ++) {n = Objeto (argumentos [c]); for (var l in n) a.call (n, l) && (s [l] = n [l]); if (o) {u = o (n); for (var p = 0; p <comprimento.p; p ++) i.call (n, u [ p]) && (s [u [p]] = n [u [p]])}} retorne s}}, função (e, t, n) {"use strict"; var r = {}; e. exportações = r}, função (e, t, n) {"use strict"; função r (e, t, n, r, a, i, u, s) {if (o (t) ,! e) { var c; if (void 0 === t) c = new Error ("Ocorreu uma exceção minimizada;use o ambiente de desenvolvimento não minificado para obter a mensagem de erro completa e outros avisos úteis. "); else {var l = [n, r, aisTopLevelUnmount: t.isTopLevelUnmount, próximo: null}, Y (n, t, r, e), t))} função G (e, t, n, r) {retorno e = e.partialState, "function" == tipo de e? e.call (t, n, r): e} função X (e, t, n) {e = e.stateNode, e .__ reactInternalMemoizedUnmaskedChildContext = t, e .__ reactInternalMemoizedMaskedChildContext = n} função J (e) { return e.tag === Wr && null! = e.type.childContextTypes} função Z (e, t) {var n = e.stateNode, o = e.type.childContextTypes; if ("function"! = typeof n.getChildContext ) retorna t; n = n.getChildContext (); para (var a em n) a em o || r ("108", f (e) || "Desconhecido", a); return vt ({}, t , n)} função ee (e, t, n) {this.tag = e, this.key = t, this.stateNode = this.type = null, this.sibling = this.child = this.return = null, this.index = 0, this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null, this.internalContextTag = n, this.effectTag = co, this.lastEffect = this.firstEffect = this.nextEffect = null, this.pendingWorkPriority = uo, this.alternate = null} função te (e, t, n) {var o = void 0; retornar "função" == tipo de e? (o = e. prototype && e.prototype.isReactComponent? new ee (Zr, t, n): new ee (Jr, t, n), o.type = e): "string" == tipo de e? (o = new ee (to, t , n), o.type = e): "objeto" == tipo de e && null! == e && "número" == tipo de e.tag? o = e: r ("130", nulo == e? e: typeof e, ""), o} função ne (e) {return null === e || void 0 === e? null: (e = Bo && e [Bo] || e ["@@ iterator"], " função "== tipo de e? e: nulo)} função re (e, t) {var n = t.ref; if (null! == n &&" função "! = tipo de n) {if (proprietário_t.) { t = t._owner; var o = void 0; t && ("número" == tipo de t.tag? (t.tag! == Ro && r ("110"), o = t.stateNode): o = t.getPublicInstance ()), o || r ("147", n);var a = "" + n; retornar nulo! == e && null! == e.ref && e.ref._stringRef === a? e.ref: (e = function (e) {var t = o.refs === kt? o.refs = {}: o.refs; null === e? delete t [a]: t [a] = e}, e._stringRef = a, e)} "string"! = typeof n && r ( "148"), t._owner || r ("149", n)} retorna n} função oe (e, t) {"textarea"! == e.type && r ("31", "[objeto Objeto]" === Object.prototype.toString.call (t)? "Objeto com as teclas {" + Object.keys (t) .join (",") + "}": t, "")} função ae (e, t) {function n (n, r) {if (t) {if (! e) {if (null === r.alternate) retorna; r = r.alternate} var o = n.últimoEffect; null! = = o? (o.nextEffect = r, n.último Efeito = r): n.firstEffect = n.último Efeito = r, r.nextEffect = nulo, r.effectTag = Ho}} função o (e, r) {if ( ! t) return null; for (; null! == r;) n (e, r), r = r.sibling; return null} função a (e, t) {for (e = new Map; null! = = t;) nulo!== t.key? e.set (t.key, t): e.set (t.index, t), t = t.sibling; return e} função i (t, n) {return e? (t = To (t, n), t.index = 0, t.sibling = null, t) :( t.pendingWorkPriority = n, t.effectTag = Lo, t.index = 0, t.sibling = null, t) } função u (e, n, r) {return e.index = r, t? null! == (r = e.alternate)? (r = r.index, r <n? (e.effectTag = Uo, n): r) :( e.effectTag = Uo, n): n} função s (e) {return t && null === e.alternate && (e.effectTag = Uo), e} função c (e, t, n , r) {return null === t || t.tag! == Ao? (n = Oo (n, e.internalContextTag, r), n.return = e, n) :( t = i (t, r), t.pendingProps = n, t.return = e, t)} função l (e, t, n, r) {return null === t || t.type! == n.type? (r = Eo (n, e.internalContextTag, r), r.ref = re (t, n), r.retorno = e, r) :( r = i (t, r), r.ref = re (t, n), r.pendingProps = n.props, r.return = e, r)} função p (e, t, n, r) {return null === t || t.tag! == jo? (n = So (n, e.internalContextTag, r), n.return = e, n) :( t = i (t, r), t.pendingProps = n, t.return = e, t)} função f (e , t, n,r) {return null === t || t.tag! == Do? (t = xo (n, e.internalContextTag, r), t.type = n.value, t.return = e, t): (t = i (t, r), t.type = n.valor, t.return = e, t)} função d (e, t, n, r) {return null === t || t.tag ! == Fo || t.stateNode.containerInfo! == n.containerInfo || t.stateNode.implementation! == n.implementation? (N = _o (n, e.internalContextTag, r), n.return = e , n) :( t = i (t, r), t.pendingProps = n.children || [], t.return = e, t)} função h (e, t, n, r) {return null = == t || t.tag! == Io? (n = Po (n, e.internalContextTag, r), n.return = e, n) :( t = i (t, r), t.pendingProps = n, t.return = e, t)} função m (e, t, n) {if ("string" == tipo de t || "número" == tipo de t) retorna t = Oo ("" + t, e.internalContextTag, n), t.return = e, t; if ("objeto" == tipo de t && null! == t) {switch (t. $$ typeof) {case Wo: retornar n = Eo (t, e .internalContextTag, n), n.ref = re (nulo, t), n.return = e, n; caso ko: return t = So (t, e.internalContextTag, n), t.return = e, t;case wo: return n = xo (t, e.internalContextTag, n), n.type = t.value, n.return = e, n; case Co: return t = _o (t, e.internalContextTag, n), t.return = e, t} se (Não (t) || ne (t)) retorna t = Po (t, e.internalContextTag, n), t.return = e, t; oe (e, t)} return null} função y (e, t, n, r) {var o = null! == t? key: null; if ("string" == tipo de n || "número" == tipo de n) retornar null! == o? null: c (e, t, "" + n, r); if ("objeto" == tipo de n && null! == n) {switch (n. $$ typeof) {case Wo: return n.key === o? l (e, t, n, r): nulo; case ko: return n.key === o? p (e, t, n, r): nulo; case wo: return nulo === o? f (e, t, n, r): null; case Co: return n.key === o (d, e, t, n, r): null} if (Não (n) || ne (n)) retorna nulo! == o? nulo: h (e, t, n, r); oe (e, n)} retorna nulo} função v (e, t, n, r, o) {if ("string" == tipo de r || "número" == tipo de r) retorna e = e.get (n) || nulo, c (t, e, "" + r, o); if (" objeto "== tipo de r && null!== r) {switch (r. $$ typeof) {case Wo: return e = e.get (null === r.key? n: r.key) || null, l (t, e, r, o); case ko: return e = e.get (null === r.key? n: r.key) || null, p (t, e, r, o); case wo: return e = e. get (n) || nulo, f (t, e, r, o); case Co: retorno e = e.get (nulo === r.key? n: r.key) || nulo, d (t , e, r, o)} if (Não (r) || ne (r)) retorna e = e.get (n) || nulo, h (t, e, r, o); oe (t, r )} retornar nulo} função g (e, r, i, s) {para (var c = nulo, l = nulo, p = r, f = r = 0, d = nulo; nulo! == p && f <i. comprimento; f ++) {p.index> f? (d = p, p = nulo): d = p.sibling; var h = y (e, p, i [f], s); if (null === h) {null === p && (p = d); break} t && p && null === h.alternado && n (e, p), r = u (h, r, f), nulo === l? c = h: l.sibling = h, l = h, p = d} if (f === comprimento i) retorna o (e, p), c; if (null === p) {for (; f <i. comprimento; f ++) (p = m (e, i [f], s)) && (r = u (p, r, f), nulo === l? c = p: l.sibling = p, l = p); return c} para (p = a (e, p); f <comprimento i; f ++) (d = v (p, e, f, i [f], s)) && (t && null! == d.alternativo && p.delete (null === d.key? f: d.key), r = u (d, r, f), nulo === l? c = d: l.sibling = d, l = d) ; return t && p.forEach (function (t) {return n (e, t)}), c} function b (e, i, s, c) {var l = ne (s); "function"! = typeof l && r ("150"), nulo == (s = l.call (s)) && r ("151"); para (var p = l = nulo, f = i, d = i = 0, h = nulo, g = s.next (); null! == f &&! g.done; d ++, g = s.next ()) {f.index> d? (h = f, f = nulo): h = f.sibling; var b = y (e, f, valor g, c); if (null === b) {f || (f = h); break} t && f && null === b.alternate && n (e, f), i = u (b, i, d), nulo === p? l = b: p.sibling = b, p = b, f = h} se (g.done) retornar o (e, f), l; Se (null === f) {for (;! g.done; d ++, g = s.next ()) null! == (g = m (e, g.valor, c)) && (i = u (g, i, d), null === p? l = g: p.sibling = g, p = g); retorna l} para (f = a (e, f) ;! g.done; d ++, g = s.next ()) null! == (g = v (f, e, d, g.value, c)) && (t && null! == g.alternate && f.delete (null === g.key? d: g.() () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () () ()) t)}), l} função de retorno (e, t, a, u) {var c = "objeto" == tipo de a && null! == a; if (c) alternar (a. $$ typeof) {case Wo: e: {var l = a.key; para (c = t; nulo! == c;) {if (c.key === l) {if (c.type === a.type) {o ( e, c.sibling), t = i (c, u), t.ref = re (c, a), t.pendingProps = a.props, t.return = e, e = t; break e} o ( e, c); break} n (e, c), c = c.sibling} u = Eo (a, e.internalContextTag, u), u.ref = re (t, a), u.return = e, e = u} retorna s (e); case ko: e: {for (c = a.key; null! == t;) {if (t.key === c) {if (t.tag == = jo) {o (e, t. irmão), t = i (t, u), t.pendingProps = a, t.retorno = e, e = t; quebra e} o (e, t); quebra} n (e, t), t = t.sibling} a = So (a, e.internalContextTag, u), a.return = e, e = a} retorna s (e); case wo: e: {if ( null! == t) {if (t.tag === Do) {o (e, t.sibling), t = i (t, u), t.type = a.value, t.return = e, e = t; quebra e} o (e, t)} t = xo (a, e.internalContextTag, u), t.type = a.value, t.return = e,e = t} retorna s (e); case Co: e: {for (c = a.key; null! == t;) {if (t.key === c) {if (t.tag == = Fo && t.stateNode.containerInfo === a.containerInfo && t.stateNode.implementation === a.implementation) {o (e, t.sibling), t = i (t, u), t.pendingProps = a.children | | [], t.return = e, e = t; quebra e} o (e, t); quebra} n (e, t), t = irmão.sim} a = _o (a, e.internalContextTag, u ), a.return = e, e = a} retorna s (e)} if ("string" == tipo de a || "número" == tipo de a) retorna a = "" + a, nulo! == t && t .tag === Ao? (o (e, t. irmão), t = i (t, u), t.pendingProps = a, t.return = e, e = t) :( o (e, t) , a = Oo (a, e.internalContextTag, u), a.return = e, e = a), s (e); se (Não (a)) retornar g (e, t, a, u); se (ne (a)) return b (e, t, a, u); if (c && oe (e, a), void 0 === a) switch (e.tag) {case Ro: case Mo: a = e .type, r ("152", a.displayName || a.name || "Component")} retorna o (e, t)}} função ie (e, t, n, o) {função a (e, t) {t.updater = i, e.stateNode = t, $ t.set (t, e)} var i = {isMounted: oa, enqueueSetState: function (n, r, o) {n = $ t.get (n); var a = t (n,! 1); Zo (n , r, void 0 === o? null: o, a), e (n, a)}, enqueueReplaceState: function (n, r, o) {n = $ t.get (n); var a = t (n,! 1); ea (n, r, void 0 === o? null: o, a), e (n, a)}, enqueueForceUpdate: function (n, r) {n = $ t.get (n); var o = t (n,! 1); ta (n, void 0 === r? null: r, o), e (n, o)}}; return {adopClassInstance: a, constructClassInstance: função (e, t) {var n = e.type, r = Xo (e), o = Jo (e), i = o? Go (e, r): kt; return t = new n (t, i ), a (e, t), o && Qo (e, r, i), t}, mountClassInstance: função (e, t) {var n = e.alternate, o = e.stateNode, a = o.state || null, u = e.pendingProps; u || r ("158"); var s = Xo (e); o.props = u, o.state = a, o.refs = kt, o.context = Go ( e, s), Sr.enableAsyncSubtreeAPI && null! = e.type && null! = e.type.prototype &&! 0 === e.type.prototype.unstable_isAsyncReactComponent && (e.internalContextTag | = $ o), "function"== tipo de o.componentWillMount && (s = o.state, o.componentWillMount (), s! == o.state && i.enqueueReplaceState (o, o.state, null), null! == (s = e.updateQueue) && (o.state = na (n, e, s, o, a, u, t))), "function" == tipo de o.componentDidMount && (e.effectTag | = Yo)}, updateClassInstance: function (e, t , a) {var u = t.stateNode; u.props = t.memoizedProps, u.state = t.memoizedState; var s = t.memoizedProps, c = t.pendingProps; c || null == (c = s ) && r ("159"); var l = u.context, p = Xo (t); if (p = Ir (t, p), "função"! = tipo de u.componWillReceiveProps || s === c && l = == p || (l = u.state, u.componentWillReceiveProps (c, p), u.state! == l && i.enqueueReplaceState (u, u.state, null)), l = t.memoizedState, a = null ! == t.updateQueue? na (e, t, t.updateQueue, u, l, c, a): l,! (s! == c || l! == a | ra () || null ! == t.updateQueue && t.updateQueue.hasForceUpdate)) retorna "função"!= typeof u.componentDidUpdate || s === e.memoizedProps && l === e.memoizedState || (t.effectTag | = Yo) ,! 1; var f = c; if (null === s || null! == t.updateQueue && t.updateQueue.hasForceUpdate) f =! 0; else {var d = t.stateNode, h = t.type; f = "function" = tipo de d.shouldComponentUpdate? d.shouldComponentUpdate (f, a, p):! (h.prototype && h.prototype.isPureReactComponent && wt (s, f) && wt (l, a))} return f? ("function" == tipo de u.componentWillUpdate && u.componentWillUpdate (c, a, p), "function "== typeof u.componentDidUpdate && (t.effectTag | = Yo)) :(" função "! = typeof u.componentDidUpdate || s === e.memoizedProps && l === e.memoizedState || (t.effectTag | = Yo), n (t, c), o (t, a)), u.props = c, u.state = a, u.context = p, f}}} função ue (e, t, n, o , a) {function i (e, t, n) {u (e, t, n, t.pendingWorkPriority)} função u (e, t, n, r) {t.child = null === e? aa (t, t.filho, n, r): e.child === t.child? ia (t, t.child, n, r): ua (t, t.child, n, r)} função s (e, t) {var n = t.ref; null === n || e && e.ref === n || (t.effectTag | = Aa)} função c (e, t, n, r) {if (s (e , t), n) return r && ma (t,! 1), p (e, t); n = t.stateNode, Fa.current = t; var o = n.render (); return t.effectTag | = _a, i (e, t, o), t.memoizedState = n.state, t.memoizedProps = n.props, r && ma (t,! 0), t.child} função l (e) {var t = e. stateNode; t.pendingContext? ha (e, t.pendingContext, t.pendingContext! == t.context): t.context && ha (e, t.context,! 1), v (e, t.containerInfo)} função p (e, t) {retornar sa (e, t), t.child} função f (e, t) {switch (t.tag) {case ba: l (t); break; case ga: da (t) ; break; case Ca: v (t, t.stateNode.containerInfo)} retornar nulo} var d = e.shouldSetTextContent, h = e.useSyncScheduling, m = e.shouldDeprioritizeSubtree, y = t.pushHostContext, v = t.pushHostContainer , g = n.enterHydrationState, b = n.resetHydrationState, k = n.tryToClaimNextHydratableInstance; e = ie (o, a, função (e, t) {e.memoizedProps = t}, função (e, t) {e.memoizedState = t}); var w = e.adoptClassInstance, C = e. construaClassInstance, T = e.mountClassInstance, E = e.updateClassInstance; return {beginWork: function (e, t, n) {if (t.pendingWorkPriority === Sa || t.pendingWorkPriority> n) return f (e, t ); switch (t.tag) {case ya: null! == e && r ("155"); var o = t.type, a = t.pendingProps, u = pa (t); return u = la (t, u), o = o (a, u), t.effectTag | = _a, "objeto" == tipo de o && null! == o && "function" == tipo de o.render? (t.tag = ga, a = da (t), w (t, o), T (t, n), t = c (e, t,! 0, a)) :( t.tag = va, i (e, t, o), t .memoizedProps = a, t = t.child), t; case va: e: {if (a = t.type, n = t.pendingProps, o = t.memoizedProps, fa ()) null === n && ( n = o); caso contrário, se (nulo === n || o === n) {t = p (e, t); break e} o = pa (t), o = la (t, o), a = a (n, o), t.effectTag | = _a, i (e, t, a), t.memoizedProps = n, t = t.filho} return t; case ga: retorna a = da (t), o = void 0, null === e? t.stateNode? r ("153") :( C (t, t.pendingProps), T ( t, n), o =! 0): o = E (e, t, n), c (e, t, o, a); case ba: retorno l (t), o = t.updateQueue, null! == o? (a = t.memoizedState, o = ca (e, t, o, nulo, a, nulo, n), a === o? (b (), t = p (e, t)) : (a = elemento, nulo! == e && nulo! == e.child ||! g (t)? (b (), i (e, t, a)) :( t.effectTag | = Na, (); t.child = aa (t, t.child, a, n)), t.memoizedState = o, t = t.child)) :( b (), t = p (e, t)), t; ka: y (t), null === e && k (t), a = t.type; var P = t.memoizedProps; return o = t.pendingProps, null === o && null === (o = P) && r ("154"), u = nulo! == e? E.memoizedProps: nulo, fa () || nulo! == o && P! == o? (P = o. crianças, d (a, o)? P = n: u && d (a, u) && (t.effectTag | = Ma), s (e, t), n! == xa &&! h && m (a, o)? (t.pendingWorkPriority = xa, t = nulo) : (i (e, t, P), t.memoizedProps = o, t = t.child)): t = p (e, t), t; case wa: return null === e &&k (t), e = t.pendingProps, null === e && (e = t.memoizedProps), t.memoizedProps = e, nulo; caso Ea: t.tag = Ta; caso Ta: retorno n = t.pendingProps , fa ()? null === n && null === (n = e && e.memoizedProps) && r ("154"): null! == n && t.memoizedProps! == n || (n = t.memoizedProps), a = n.children, o = t.pendingWorkPriority, t.stateNode = null === e? aa (t, t.stateNode, a, o): e.child === t.child? ia (t, t.stateNode , a, o): ua (t, t.stateNode, a, o), t.memoizedProps = n, t.stateNode; case Pa: return null; case Ca: e: {if (v (t, t.stateNode .containerInfo), n = t.pendingWorkPriority, a = t.pendingProps, fa ()) null === a && null == (a = e && e.memoizedProps) && r ("154"); else if (null === a | | t.memoizedProps === a) {t = p (e, t); break e} null === e? t.child = ua (t, t.child, a, n): i (e, t , a), t.memoizedProps = a, t = t.child} retorna t; case Oa: e: {if (n = t.pendingProps, fa ()) null === n && (n = t.memoizedProps);caso contrário, se (null === n || t.memoizedProps === n) {t = p (e, t); quebra e} i (e, t, n), t.memoizedProps = n, t = t. filho} retornar t; padrão: r ("156")}}, beginFailedWork: function (e, t, n) {switch (t.tag) {case ga: da (t); break; case ba: l (t ); break; default: r ("157")} return t.effectTag | = Ra, null === e? t.child = null: t.child! == e.child && (t.child = e.child ), t.pendingWorkPriority === Sa || t.pendingWorkPriority> n? f (e, t) :( t.firstEffect = null, t.lastEffect = null, u (e, t, null, n), t. tag === ga && (e = t.stateNode, t.memoizedProps = e.props, t.memoizedState = e.state), t.child)}}} function se (e, t, n) {var o = e .createInstance, a = e.createTextInstance, i = e.appendInitialChild, u = e.finalizeInitialChildren, s = e.prepareUpdate, c = t.getRootHostContainer, l = t.popHostContext, p = t.getHostContext, f = t.popHostContext , d = n.prepareToHydrateHostInstance, h = n.prepareToHydrateHostTextInstance, m = n.popHydrationState;return {completeWork: function (e, t, n) {var y = t.pendingProps; switch (null === y? y = t.memoizedProps: t.pendingWorkPriority === Ja && n! == Ja || (t. pendingProps = null), t.tag) {case Ua: return null; case Ha: return Da (t), null; case Ba: return f (t), Ia (t), y = t.stateNode, y.pendingContext && (y.context = y.pendingContext, y.pendingContext = null), null! == e && null! == e.child || (m (t), t.effectTag & = ~ Qa), null; case Wa: l ( t), n = c (); var v = t.type; if (null! == e && null! = t.stateNode) {var g = e.memoizedProps, b = t.stateNode, k = p (); y = s (b, v, g, y, n, k), (t.updateQueue = y) && (t.effectTag | = Xa), e.ref! == t.ref && (t.effectTag | = Ga) } else {if (! y) retorna null === t.stateNode && r ("166"), null; if (e = p (), m (t)) d (t, n, e) && (t.effectTag | = Xa); else {e = o (v, y, n, e, t); e: for (g = t.child; null! == g;) {if (g.tag === Wa | | g.tag === Va) i (e, g.stateNode); caso contrário, se (g.tag! == Ka && null! == g.filho) {g = g.child; continue} if (g === t) quebra e; para (; null === g.sibling;) {if (null === g.return || g.return = == t) break e; g = g.return} g = g.sibling} u (e, v, y, n) && (t.effectTag | = Xa), t.stateNode = e} null! == t .ref && (t.effectTag | = Ga)} return null; case Va: if (e && null! = t.stateNode) e.memoizedProps! == y && (t.effectTag | = Xa); else {if ("string"! = tipo de y) return null === t.stateNode && r ("166"), null; e = c (), n = p (), m (t)? h (t) && (t.effectTag | = Xa) : t.stateNode = a (y, e, n, t)} retorna nulo; caso za: (y = t.memoizedProps) || r ("165"), t.tag = qa, n = []; e : for ((v = t.stateNode) && (v.return = t); null! == v;) {if (v.tag === Wa || v.tag === Va || v.tag === Ka) r ("164"); else if (v.tag === Ya) n.push (v.type); else if (null! == v.child) {v.child.return = v, v = v.child; continue} for (; null === v.sibling;) {if (null === v.return || v.return === t) interrompa e; v = v.return } v.sibling.return = v.return, v = v.sibling} retorna v = y.handler, y = v (y.props, n), t.child = ja (t, null! == e? e.child: null, y, t.pendingWorkPriority), t.child; case qa: return t.tag = za, null; case Ya: case $ a: return null; case Ka: return t.effectTag | = Xa, f (t), null ; case La: r ("167"); padrão: r ("156")}}}} função ce (e) {função de retorno (t) {tente {return e (t)} catch (e) {}} } função le (e, t) {função n (e) {var n = e.ref; if (null! == n) tente {n (null)} catch (n) {t (e, n)}} função o (e) {return e.tag === oi || e.tag === ri || e.tag === ii} função a (e) {para (var t = e ;;) if ( u (t), null! == t.child && t.tag! == ii) t.child.return = t, t = t.child; else {if (t === e) quebra; for (; null = == t.sibling;) {if (null === retorno t |retorno || t.return === e) retorno; t = retorno t.} t.sibling.return = retorno t, t = t.sibling }} função i (e) {para (var t = e, n =! 1, o = nulo 0, i = nulo 0 ;;) {if (! n) {n = t.return; e: for (; ;) {switch (null === n && r ("160"), n.tag) {case oi:o = n.stateNode, i =! 1; break e; case ri: case ii: o = n.stateNode.containerInfo, i =! 0; break e} n = n.return} n =! 0} if (t .tag === oi || t.tag === ai) a (t), i? v (o, t.stateNode): y (o, t.stateNode); caso contrário, se (t.tag === ii? o = t.stateNode.containerInfo: u (t), null! == t.child) {t.child.return = t, t = t.child; continue} se (t === e) quebrar; for (; null === t.sibling;) {if (null === t.return || t.return === e) return; t = t.return, t.tag === ii && (n = ! 1)} t.sibling.return = t.return, t = t.sibling}} função u (e) {switch ("function" == tipo de ci && ci (e), e.tag) {case ni: n ( e); var r = e.stateNode; if ("função" = tipo de r.componentWillUnmount) tente {r.props = e.memoizedProps, r.state = e.memoizedState, r.componentWillUnmount ()} catch (n) {t (e, n)} break; case oi: n (e); break; case ui: a (e.stateNode); break; case ii: i (e)}} var s = e.commitMount, c = e.commitUpdate, l = e.resetTextContent, p = e.commitTextUpdate, f = e.appendChild, d = e.appendChildToContainer, h = e.insertBefore, m = e.insertInContainerBefore, y = e.removeChild, v = e.removeChildFromContainer, g = e.getPublicInstance; return {commitPlacement: function (e) {e: {for (var t = e .return; null! == t;) {if (o (t)) {var n = t; break e} t = t.return} r ("160"), n = nulo 0} var a = t = void 0; switch (n.tag) {case oi: t = n.stateNode, a =! 1; break; case ri: case ii: t = n.stateNode.containerInfo, a =! 0; break; padrão: r ("161")} n.effectTag & di (l (t), n.effectTag & = ~ di); e: t: for (n = e ;;) {for (; null === n.sibling;) {if (null === n.retorno || o (n.retorno)) {n = nulo; quebra e} n = n.retorno} para (n.sibling.return = n.return, n = n.sibling; n .tag! == oi && n.tag! == ai;) {if (n.effectTag & li) continue t; if (null === n.child || n.tag === ii) continue t; n.child. return = n, n = n.child} if (! (n.effectTag & li)) {n = n.stateNode; break e}} para (var i = e ;;) {if (i.tag === oi | | i.tag === ai) n? a? m (t, i.stateNode, n): h (t, i.stateNode, n): a? d (t, i.stateNode): f (t, i.stateNode); caso contrário, se (i.tag! == ii && null! == i.child) {i.child.return = i , i = i.child; continue} if (i === e) break; for (; null === i.sibling;) {if (null === i.return || i.return === e ); return; i = i.return} i.sibling.return = i.return, i = i.sibling}}, commitDeletion: function (e) {i (e), e.return = null, e.child = null , e.alternate && (e.alternate.child = null, e.alternate.return = null)}, commitWork: function (e, t) {switch (t.tag) {case ni: break; case oi: var n = t.stateNode; if (null! = n) {var o = t.memoizedProps; e = null! == e? e.memoizedProps: o; var a = t.type, i = t.updateQueue; t.updateQueue = null, null! == i && c (n, i, a, e, o, t)} break; case ai: null === t.stateNode && r ("162"), n = t.memoizedProps, p (t.stateNode , null! == e? e.memoizedProps: n, n); break; case ri: case ii: break; padrão: r ("163")}}, commitLifeCycles: function (e, t) {switch (t. tag) {case ni: var n = t.stateNode; if (t.effectTag & pi) if (null === e) n.props = t.memoizedProps, n.state = t.memoizedState, n.componentDidMount (); else {var o = e.memoizedProps; e = e .memoizedState, n.props = t.memoizedProps, n.state = t.memoizedState, n.componentDidUpdate (o, e)} t.effectTag & fi && null! == t.updateQueue && si (t, t.updateQueue, n); break; case ri: null! == (e = t.updateQueue) && si (t, e, t.child && t.child.stateNode); break; case oi: n = t.stateNode, null === e &&t.effectTag & pi && s (n, t .type, t.memoizedProps, t); break; case ai: case ii: break; default: r ("163")}}, commitAttachRef: function (e) {var t = e.ref; if (null! = = t) {var n = e.stateNode; switch (e.tag) {case oi: t (g (n)); break; padrão: t (n)}}}, commitDetachRef: function (e) {null! == (e = e.ref) && e (null)}}} função pe (e) {função t (e) {return e === vi && r ("174"), e} var n = e.getChildHostContext, o = e.getRootHostContext, a = hi (vi), i = hi (vi), u = hi (vi); return {getHostContext: function () {return t (a.current)}, getRootHostContainer: function () {return t (u .current)}, popHostContainer: função (e) {mi (a, e), mi (i, e), mi (u, e)}, popHostContext: função (e) {i.current === e && (mi (a, e), mi (i, e))}, pushHostContainer: function (e, t) {yi (u, t, e), t = o (t), yi (i, e, e), yi (a, t, e)}, pushHostContext: function (e) {var r = t (u.current), o = t (a.current); r = n (o, e.type, r), o! == r && (yi (i, e, e), yi (a, r, e))}, resetHostContainer: function () {a.current = vi, u.current = vi}}} function fe (e) { função t (e, t) {var n = Ti (); n.stateNode = t, n.return = e, n.effectTag = wi, null! == e.lastEffect? ​​(e.lastEffect.nextEffect = n, e.lastEffect = n): e.firstEffect = e.lastEffect = n} função n (e, t) {switch (e.tag) {case gi: return i (t, e.type, e.pendingProps); case bi: return u (t, e.pendingProps); padrão: return! 1}} função o (e) {for (e = e.return; null!== e && e.tag! == gi && e.tag! == ki;) e = e.return; h = e} var a = e.shouldSetTextContent, i = e.canHydrateInstance, u = e.canHydrateTextInstance, s = e. getNextHydratableSibling, c = e.getFirstHydratableChild, l = e.hydrateInstance, p = e.hydrateTextInstance, f = e.didNotHydrateInstance, d = e.didNotFindHydratableInstance; if (e = e & amp; () {return! 1}, resetHydrationState: function () {}, tryToClaimNextHydratableInstance: function () {}, prepareToHydrateHostInstance: function () {r ("175")}, prepareToHydrateHostTextInstance: function () {r ("176") }, popHydrationState: function () {return! 1}}; var h = null, m = null, y =! 1; return {enterHydrationState: function (e) {return m = c (e.stateNode.containerInfo), h = e, y =! 0}, resetHydrationState:function () {m = h = null, y =! 1}, tryToClaimNextHydratableInstance: function (e) {if (y) {var r = m; if (r) {if (! n (e, r)) {if (! (r = s (r)) ||! n (e, r)) return e.effectTag | = Ci, y =! 1, vazio (h = e); t (h, m)} e.stateNode = r, h = e, m = c (r)} else e.effectTag | = Ci, y =! 1, h = e}}, prepareToHydrateHostInstance: function (e, t, n) {return t = l (e .stateNode, e.type, e.memoizedProps, t, n, e), e.updateQueue = t, nulo! == t}, prepareToHydrateHostTextInstance: function (e) {return p (e.stateNode, e.memoizedProps, e )}, popHydrationState: function (e) {if (e! == h) retorna! 1; if (! y) retorna o (e), y =! 0,! 1; var n = e.type; if ( e.tag! == gi || "head"! == n && "body"! == n &&! a (n, e.memoizedProps)) para (n = m; n;) t (e, n), n = s (n); return o (e), m = h? s (e.stateNode): null,! 0}}} função de (e) {function t () {for (; null! == q && q. current.pendingWorkPriority === Ni;) {q.isScheduled =! 1; var e = q.nextScheduledRoot; if (q.nextScheduledRoot = null,q === Y) retorna Y = q = nulo, V = Ni, nulo; q = e} e = q; para (var t = nulo, n = Ni; nulo! == e;) e.current.pendingWorkPriority ! == Ni && (n === Ni || n> e.current.pendingWorkPriority) && (n = e.current.pendingWorkPriority, t = e), e = e.nextScheduledRoot; null! == t? (V = n, Pi (), Xi (), C (), W = Si (corrente t, n), t! == oe && (re = 0, oe = t)) :( V = Ni, oe = W = null)} função n (n) {ee =! 0, z = null; var o = n.stateNode; if (o.current === n && r ("177"), V! == Mi && V! == Ri | | re ++, Oi.current = null, n.effectTag> Ii) if (null! == n.lastEffect) {n.lastEffect.nextEffect = n; var a = n.firstEffect} else a = n; else a = n .firstEffect; para (j (), K = a; null! == K;) {vari =! 1, u = nulo 0; tente {for (; null! == K;) {var s = K. effectTag; if (s & Wi && e.resetTextContent (K.stateNode), s & zi) {var c = K.alternate; null! == c &&R (c)} switch (s & ~ (Vi | Ki | Wi | zi | Ii)) {case Li: S (K), K.effectTag & = ~ Li; break; case Hi: S (K), K.effectTag &= ~ Li, _ (K.alternate, K); break; case Ui: _ (K.alternate, K); break; case Bi: te =! 0, x (K), te =! 1} K = K .nextEffect}} catch (e) {i =! 0, u = e} i && (null === K&& r ("178"), p (K, u), null! == K&& (K = K.nextEffect) )} para (D (), o.current = n, K = a; null! == K;) {o =! 1, a = void 0; tente {for (; null! == K;) {var l = K.effectTag; if (l & (Ui | Vi) && N (K.alternate, K), l & zi && M (K), l & Ki) comutador (i = K, u = nulo 0, nulo! == Q && (u = Q .get (i), Q.delete (i), null == u && null! == i.alternate && (i = i.alternate, u = Q.get (i), Q.delete (i))), null = = u && r ("184"), i.tag) {case Qi: i.stateNode.componentDidCatch (u.error, {componentStack: u.componentStack}); break; case qi: null === J&& (J = u. erro); quebra; padrão: r ("157")} var f = K.nextEffect; K.nextEffect = nulo, K = f}} captura (e) {o =! 0, a = e} o && (null = == K&&r ("178"), p (K, a), nulo! == K&& (K = K.nextEffect))} ee =! 1, "function" == tipo de _i && _i (n.stateNode), X && (X.forEach (v), X = null), t ()} função o (e) {for (;; ) {var t = O (e.alternate, e, V), n = e.return, r = e.sibling, o = e; if (! (o.pendingWorkPriority! == Ni && o.pendingWorkPriority> V)) { for (var a = Gi (o), i = o.child; null! == i;) a = xi (a, i.pendingWorkPriority), i = i.sibling; o.pendingWorkPriority = a} if (null! == t) return t; if (null! == n && (null === n.firstEffect && (n.firstEffect = e.firstEffect)), null! == e.lastEffect && (null! == n.lastEffect && (n. lastEffect.nextEffect = e.firstEffect), n.lastEffect = e.lastEffect), e.effectTag> Ii && (null! == n.lastEffect? ​​n.lastEffect.nextEffect = e: n.firstEffect = e, n.lastEffect = e)), null! == r) return r; if (null === n) {z = e; break} e = n} retorna null} função a (e) {var t = E (e.alternate, e, V); return null === t && (t = o (e)), Oi.current = null,t} função i (e) {var t = P (e.alternate, e, V); return null === t && (t = o (e)), Oi.current = null, t} função u (e) {l (ji, e)} função s () {if (null! == Q && 0 <Q.size && V === Ri) para (; null! == W;) {var e = W; if (null == = (W = null! == Q&& (Q.has (e) || null! == e.alternate && Q.has (e.alternate))? I (W): a (W)) && (null === z && r ("179"), I = Ri, n (z), I = V, nulo === Q || 0 === Q.size || V! == Ri)) interrupção}} função c (e , o) {if (null! == z? (I = Ri, n (z), s ()): null === P & t (),! (V === Ni || V> e)) { I = V; e: para (;;) {if (V <= Ri) para (; null! == W &&! (Null === (W = a (W)) && (null === z && r (" 179 "), I = Ri, n (z), I = V, s (), V === Ni || V> e || V> Ri));); caso contrário, se (nulo! == o) for (; null! == W &&! U;) if (1 <o.timeRemaining ()) {if (null === (W = a (W))) if (null === z && r ("179") , 1 <o.timeRemaining ()) {if (I = Ri, n (z), I = V, s (), V === Ni || V> e || V <Ai) break} else U = !0} else U =! 0; switch (V) {case Mi: case Ri: if (V <= e) continue e; break e; case Ai: case Fi: case ji: if (null === o) break e; se (! U && V <= e) continuar e; break e; case Ni: break e; padrão: r ("181")}}}} função l (e, t) {L && r ("182"), L =! 0; var n = I, o =! 1, a = null; tente {c (e, t)} catch (e) {o =! 0, a = e} para (; o;) {if ( Z) {J = a; break} var s = W; if (null === s) Z =! 0; else {var l = p (s, a); if (null === l && r ("183" ), Z) {try {o = l, a = e, l = t; para (var f = o; null! == s;) {switch (s.tag) {case Qi: Ei (s); break; case Yi: w (s); break; case qi: k (s); break; case $ i: k (s)} if (s === f || s.alternate === f) break; s = s.return} W = i (o), c (a, l)} catch (e) {o =! 0, a = e; continue} break}}} if (I = n, null! == t && ($ =! 1), V> Ri &&! $ && (A (u), $ =! 0), e = J, Z = U = L =! 1, oe = G = Q = J = nulo, re = 0, nulo! == e) lança e} função p (e, t) {var n = Oi.corrente = nulo, r =! 1, o =! 1, a = nulo; if (e.tag == = qi) n = e, d (e) && (Z =! 0);else for (var i = e.retorno; null! == i && null === n;) {if (i.tag === Qi? "function" == tipo de i.stateNode.componentDidCatch && (r =! 0, a = f (i), n = i, o =! 0): i.tag === qi && (n = i), d (i)) {if (te || nulo! == X && (X.has ( i) || null! == i.alternate && X.has (i.alternate))) return null; n = null, o =! 1} i = i.return} if (null! == n) {null == = G&& (G = novo conjunto), G.add (n); var u = ""; i = e; faça {e: switch (i.tag) {case fo: case ho: case mo: case yo: var s = i._debugOwner, c = i._debugSource, l = f (i), p = nulo; s && (p = f (s)), s = c, l = "\ n em" + (l || " Desconhecido ") + (s?" (Em "+ s.fileName.replace (/^.*[\\\/unette/ ,"")+":"+ s.lineNumber +") ": p?" (Criado por "+ p +") ":" "); quebra e; padrão: l =" "} u + = l, i = retorno do retorno} enquanto (i); i = u, e = f (e), nulo = == P&R (Q = novo mapa), t = {componentName: e, componentStack: i,erro: t, errorBoundary: r? n.stateNode: null, errorBoundaryFound: r, errorBoundaryName: a, willRetry: o}, Q.set (n, t); tente {console.error (t.error)} catch (e ) {console.error (e)} retorna ee? (null === X && (X = novo conjunto), X.add (n)): v (n), n} retorna null === J&& (J = t ), null} função d (e) {return null! == G&& (G.has (e) || null! == e.alternate && G.has (e.alternate))} function h (e, t) {return função m (e, t,! 1)} m (e, t) {re> ne && (Z =! 0, r ("185")) ,! L && t <= V&& (W = nulo); for (var n =! 0; null! == e && n;) {if (n =! 1, (e.pendingWorkPriority === Ni || e.pendingWorkPriority> t) && (n =! 0, e.pendingWorkPriority = t), nulo ! == e.alternate && (e.alternate.pendingWorkPriority === Ni || e.alternate.pendingWorkPriority> t) && (n =! 0, e.alternate.pendingWorkPriority = t), null === e.return {if (e.tag! == qi) break; var o = e.stateNode; if (t === Ni || o.isScheduled || (o.isScheduled =! 0, Y? Y.nextScheduledRoot = o: q = o, Y = o) ,! L) switch (t) {case Mi: B? l (Mi, null): l ( Ri, nulo); break; case Ri: H || r ("186"); break; default: $ || (A (u), $ =! 0)}} e = e.return}} função y ( e, t) {var n = I; return n === Ni && (n =! F || e.internalContextTag & Di || t? Fi: Mi), n === Mi && (L || H)? Ri: n } função v (e) {m (e, Ri,! 0)} var g = pe (e), b = fe (e), k = g.popHostContainer, w = g.popHostContext, C = g.resetHostContainer, T = ue (e, g, b, h, y), E = T.beginWork, P = T.beginFailedWork, O = se (e, g, b) .completeWork; g = le (e, p); var S = g.commitPlacement, x = g.commitDeletion, _ = g.commitWork, N = g.commitLifeCycles, M = g.commitAttachRef, R = g.commitDetachRef, A = e.scheduleDeferredCallback, F = e.useSyncScheduling, j = e.prepareForCommit, D = e.resetAfterCommit, I = Ni, L =! 1, U =! 1, H =! 1, B =! 1, W = nulo, V = Ni, K = nulo, z = nulo, q = nulo, Y = nulo, $ =! 1, Q = nulo, G = nulo, X = nulo, J = nulo, Z =! 1, ee =! 1, te =! 1, ne = 1e3, re = 0, oe = nulo;return {scheduleUpdate: h, getPriorityContext: y, batchedUpdates: function (e, t) {var n = H; H =! 0; tente {return e (t)} finalmente {H = n, L || H || l (Ri, null)}}, uncatchedUpdates: function (e) {var t = B, n = H; B = H, H =! 1; tente {return e ()} finalmente {H = n, B = t} } flushSync: function (e) {var t = H, n = I; H =! 0, I = Mi; tente {retornar e ()} finalmente {H = t, I = n, L&&r ("187") , l (Ri, null)}}, adiadoUpdates: function (e) {var t = I; I = Fi; tente {return e ()} finalmente {I = t}}}} function he () {r (" 196 ")} function me (e) {return e? (E = $ t.get (e)," number "== tipo de e.tag? He (e): e._processChildContext (e._context)): kt } função ye (e) {para (; e && e.firstChild;) e = e.firstChild; return e} função ve (e, t) {var n = ye (e); e = 0; para (var r; n ;) {if (n.nodeType === au) {if (r = e + n.textContent.length, e <= t && r> = t) retornar {nó: n, deslocamento: te}; e = r} e : {for (; n;) {if (n.nextSibling) {n = n.nextSibling; break e} n = n.parentNode} n = void 0} n = ye (n)}} função ge () {return! iu && yt.canUseDOM && (iu = "textContent" em document.documentElement? "textContent": "innerText"), iu} função be ( ) {r ("211")} função ke () {r ("212")} função nós (e) {if (null == e) retorna nulo; if (e.nodeType === pu) return e; var t = $ t.get (e); se (t) retornar "número" == tipo de t.tag? be (t): ke (t); "função" == tipo de e.render? r ("188 "): r (" 213 ", Object.keys (e))} função Ce (e) {if (void 0! == e._hostParent) retorna e._hostParent; if (" number "== typeof e.tag ) {faça ​​{e = e.retorno} while (e && e.tag! == fu); se (e) retornar e} retornar nulo} função Te (e, t) {para (var n = 0, r = e; r; r = Ce (r)) n ++; r = 0; para (var o = t; o; o = Ce (o)) r ++; para (; 0 <nr;) e = Ce (e), n- -; para (; 0 <rn;) t = Ce (t), r -; para (; n -;) {if (e === t || e === t.alternate) return e; e = Ce (e),t = Ce (t)} retorna nulo} função Ee (e, t, n) {(t = hu (e, n.dispatchConfig.phasedRegistrationNames [t])) && (n._dispatchListeners = P (n._dispatchListeners, t ), n._dispatchInstances = P (n._dispatchInstances, e))} função Pe (e) {e && e.dispatchConfig.phasedRegistrationNames && du.traverseTwoPhase (e._targetInst, Ee, e)} função Oe (e) {if (e &&fig) .phasedRegistrationNames) {var t = e._targetInst; t = t? du.getParentInstance (t): null, du.traverseTwoPhase (t, Ee, e)}} function Se (e, t, n) {e && n && n.dispatchConfig. registrationName && (t = hu (e, n.dispatchConfig.registrationName)) && (n._dispatchListeners = P (n._dispatchListeners, t), n._ispatchInstances = P (n._dispatchInstances, e))} function xe (e) e && e.dispatchConfig.registrationName && Se (e._targetInst, null, e)} function _e (e, t, n, r) {this.dispatchConfig = e, this._targetInst = t,this.nativeEvent = n, e = this.constructor.Interface; for (var o em e) e.hasOwnProperty (o) && ((t = e [o])? this [o] = t (n): "target "=== o? this.target = r: este [o] = n [o]); retorna this.isDefaultPrevented = (nulo! = n.defaultPrevented? n.defaultPrevented:! 1 === n.returnValue)? bt.thatReturnsTrue: bt.thatReturnsFalse, this.isPropagationStopped = bt.thatReturnsFalse, this} function Ne (e, t, n, r) {if (this.eventPool.length) {var o = this.eventPool.pop (); retorne this.call (o, e, t, n, r), o} retorne new this (e, t, n, r)} função Me (e) {e instância disso || r ("223"), e .destructor (), 10> this.eventPool.length && this.eventPool.push (e)} função Re (e) {e.eventPool = [], e.getPooled = Ne, e.release = Me} função Ae (e, t, n, r) {return _e.call (this, e, t, n, r)} função Fe (e, t, n, r) {return _e.call (this, e, t, n, r) } função je (e, t) {switch (e) {case "topKeyUp": return-1! == wu.indexOf (t.keyCode);case "topKeyDown": return 229! == t.keyCode; case "topKeyPress": case "topMouseDown": case "topBlur": return! 0; padrão: return! 1}} função De (e) {return e = e .detalhe, "objeto" == tipo de e && "dados" em e? e.data: null} função Ie (e, t) {switch (e) {case "topCompositionEnd": return De (t); case "topKeyPress" : return 32! == t.which? null: (Nu =! 0, xu); case "topTextInput": return e = t.data, e === xu && Nu? null: e; padrão: return null}}: Le (e, t) {se (Mu) retornar "topCompositionEnd" === e ||! Cu && je (e, t)? (E = gu.getData (), gu.reset (), Mu =! 1, e ): null; switch (e) {case "topPaste": retorna null; case "topKeyPress": if (! (t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {if (t.char && 1 <t.char.length) retorna t.char; if (t.qual) retorna String.fromCharCode (t.qual)} retorna nulo; case "topCompositionEnd": retorna Su? null: t.data; padrão: retorna nulo}} função Ue (e) {var t = e && e.nodeName && e.nodeName.toLowerCase (); return "input" = Au [e.type]: "textarea" === t} função He (e, t, n) {return e = _e.getPooled (Fu.change, e, t, n), e .type = "change", fn.enqueueStateRestore (n), mu.accumulateTwoPhaseDispatches (e), e} função Be (e) {wn.enqueueEvents (e), wn.enqueueEvents (e), wn.processEventQueue (! 1)} função We (e) { var t = Yt.getNodeFromInstance (e); if (Zn.updateValueIfChanged (t)) retorna e} função Ve (e, t) {if ("topChange" === e) retorna t} função Ke () {ju && ( ju.detachEvent ("onpropertychange", ze), Du = ju = null)} função ze (e) {"value" === e.propertyName && We (Du) && (e = He (Du, e, T (e)) ), hn.batchedUpdates (Be, e))} função qe (e, t, n) {"topFocus" === e? (Ke (), ju = t, Du = n, ju.attachEvent ("onpropertychange", ze)): "topBlur" === e && Ke ()} função Ye (e) {if ("topSelectionChange" === e || "topKeyUp" === e || "topKeyDown" = == e) return We (Du)} função $ e (e, t) {if ("topClick" === e) return We (t)} função Qe (e, t) {if ("topInput" == = e || "topChange" === e) return We (t)} função Ge (e, t, n, r) {retorno _e.call (this, e, t, n, r)} função Xe (e ) {var t = this.nativeEvent; return t.getModifierState? t.getModifierState (e): !! (e = Uu [e]) && !! t [e]} função Je () {retornar Xe} função Ze ( e, t, n, r) {return _e.call (this, e, t, n, r)} função et (e, t) {if ($ u || nulo == zu || zu! == Et ()) return null; var n = zu; return "selectionStart" em n && lu.hasSelectionCapabilities (n)? n = {start: n.selectionStart, end: n.selectionEnd}: window.getSelection? (n = window.getSelection ( ), n = {anchorNode: n.anchorNode, anchorOffset:n.anchorOffset, focusNode: n.focusNode, focusOffset: n.focusOffset}): n = nulo 0, Yu && wt (Yu, n)? null: (Yu = n, e = _e.getPooled (Ku.select, qu, e , t), e.type = "selecionar", e.target = zu, mu.accumulateTwoPhaseDispatches (e), e)} função tt (e, t, n, r) {retornar _e.call (this, e, t , n, r)} função nt (e, t, n, r) {return _e.call (this, e, t, n, r)} função rt (e, t, n, r) {return _e.call (this, e, t, n, r)} função ot (e) {var t = e.keyCode; retorna "charCode" em e? 0 === (e = e.charCode) && 13 === t && (e = 13): e = t, 32 <= e || 13 === e? E: 0} função em (e, t, n, r) {retorna _e.call (this, e, t, n, r )} function it (e, t, n, r) {return _e.call (this, e, t, n, r)} função ut (e, t, n, r) {return _e.call (this, e , t, n, r)} função st (e, t, n, r) {return _e.call (this, e, t, n, r)} função ct (e, t, n, r) {return _e .call (this, e, t, n, r)} função lt (e) {return e [1] .toUpperCase ()} função pt (e) {return! (! e || e.nodeType! == ds && e .nodeType!== ys && e.nodeType! == vs && (e.nodeType! == ms || "reatar-ponto-de-montagem-instável"! == e.nodeValue))} função ft (e) {return! (! (e = e.nodeType === ys? e.documentElement: e.firstChild: null) || e.nodeType! == ds ||! e.hasAttribute (gs))} função dt (e, t, n, o , a) {pt (n) || r ("200"); var i = n._reactRootContainer; if (i) js.updateContainer (t, i, e, a); else {if (! o &&! ft ( n)) para (o = void 0; o = n.lastChild;) n.removeChild (o); var u = js.createContainer (n); i = n._reactRootContainer = u, js.unbatchedUpdates (function () { js.updateContainer (t, u, e, a)})} retornar js.getPublicRootInstance (i)} função ht (e, t) {var n = 2 <argumentos.length && void 0! == argumentos [2]? argumentos [ 2]: null; return pt (t) || r ("200"), bo.createPortal (e, t, null, n)} var mt = n (0); n (36); var yt = n ( 37), vt = n (38), gt = n (39), bt = n (19), kt = n (40), wt = n (41), Ct = n (42), Tt = n (45) ), Et = n (46); mt || r ("227"); var Pt, Ot,St = {Namespaces: {html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http: / /www.w3.org/2000/svg"},getIntrinsicNamespace:o,getChildNamespace:function(e,t){return null == e || "http://www.w3.org/1999/xhtml" == = e? o (t): "http://www.w3.org/2000/svg" === e && "ForeignObject" === t? "http://www.w3.org/1999/xhtml" : e}}, xt = null, _t = {}, Nt = {plug-ins: [], eventNameDispatchConfigs: {}, registrationNameModules: {}, registrationNameDependencies: {}, possibleNameRegistrationNames: null, injectEventPluginOrder: function (e) {xt && r ( "101"), xt = Array.prototype.slice.call (e), a ()}, injectEventPluginsByName: function (e) {var t, n =! 1; para (t em e) if (e.hasOwnProperty ( t)) {var o = e [t]; _ t.hasOwnProperty (t) && _ t [t] === o || (_t [t] && r ("102", t), _ t [t] = o, n =! 0)} n &&a ()}}, Mt = Nt, Rt = {filhos:! 0, DangerousSetInnerHTML:! 0, foco automático: 0, valor padrão: 0, defaultChecked:! 0, innerHTML: 0, suppressContentEditableWarning: 0, estilo: ! 0}, Em = {MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLE: {}, o = e.DOMAttributeNamespaces || {}, a = e.DOMAttributeNames || {}; e = e.DOMMutationMethods || {}; for (vari in n) {Ft.properties.hasOwnProperty (i) && r ("48", i); var s = i.toLowerCase (), c = n [i]; s = {attributeName: s, attributeNamespace: null, propertyName: i, mutationMethod: null, mustUseProperty: u (c, t .MUST_USE_PROPERTY), hasBooleanValue: u (c, t.HAS_BOOLEAN_VALUE), hasNumericValue: u (c, t.HAS_NUMERIC_VALUE), hasPositiveNumericValue: u (c, t.HAS_POSITIVE_NUMERIC_VALUE).HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: u (c, t.HAS_STRING_BOOLEAN_VALUE)}, 1> = s.hasBooleanValue + s.hasNumericValue + s.hasOverloadedBooleanValue || r ("50", i), attributeName = a [i]), o.hasOwnProperty (i) && (s.attributeNamespace = o [i]), e.hasOwnProperty (i) && (s.mutationMethod = e [i]), Ft.properties [i] = s}}}, Ft = {ID_ATTRIBUTE_NAME: "data-reactid", ROOT_ATTRIBUTE_NAME: "data-reacttroot", ATTRIBUTE_NAME_START_CHAR: ": A-Z_a-z \\ u00C0 - \\ u00D6 \\ u00D6 \\ u00D6 - \\ u00D6 u00F8 - \\ u02FF \\ u0370 - \\ u037D \\ u037F - \\ u1FFF \\ u200C - \\ u200D \\ u2070 - \\ u218F \\ u2C00 - \\ u2FEF \\ u3001 - \\ uD7FF \\ uF900 - \\ uFDCF \\ uFDF0 - \\ uFFFD ", ATTRIBUTE_NAME_CHAR:":A-Z_a-z \\ u00C0 - \\ u00D6 \\ u00D8 - \\ u00F6 \\ u00F8 - \\ u02FF \\ u0370 - \\ u037D \\ u037F - \\ u1FFF \\ u200C - \\ u200D \\ u2070 - \\ u218F \\ u2C00 - \\ u2FEF \\ u3001 - \\ uD7FF \\ uF900 - \\ uFDCF \\ uFDF0 - \\ uFFFD \\ -. 0-9 \\ u00B7 \\ u0300 - \\ u036F \ \ u203F - \\ u2040 ", propriedades: {}, shouldSetAttribute: function (e, t) {if (Ft.isReservedProp (e) ||! (" o "! == e [0] &&" O "! =" = e [0] || "n"! == e [1] && "N"! == e [1])) return! 1; if (null === t) return! 0; switch (tipo de t ) {case "boolean": return Ft.shouldAttributeAcceptBooleanValue (e); case "undefined": case "number": case "string": case "object": return! 0; default: return! 1}}, getPropertyInfo: function (e) {return Ft.properties.hasOwnProperty (e)? Ft.properties [e]: null}, shouldAttributeAcceptBooleanValue: function (e) {if (Ft.isReservedProp (e)) return! 0; var t = Ft.getPropertyInfo (e); retornar t? t.hasBooleanValue || t.hasStringBooleanValue || t.hasOverloadedBooleanValue: "data -" === (e = e.toLowerCase (). slice (0,5)) || "ária -" === e}, isReservedProp: function (e) {return Rt.hasOwnProperty (e)}, injeção: At}, jt = Ft, Dt = {IndeterminateComponent: 0, FunctionalComponent: 1, ClassComponent: 2, HostRoot: 3, HostPortal: 4, HostComponent: 5, HostText : 6, CoroutineComponent: 7, CoroutineHandlerPhase: 8, YieldComponent: 9, Fragmento: 10}, It = {ELEMENT_NODE: 1, TEXT_NODE: 3, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_FRAGMENT_NODE: 11}, Lt = Dt.Com, Ut = Dt.HostText, Ht = It.ELEMENT_NODE, Bt = It.COMMENT_NODE, Wt = jt.ID_ATTRIBUTE_NAME, Vt = {hasCachedChildNodes: 1}, Kt = Math.random (). ToString (36) .slice (2), zt = "__ reactInternalInstance $" + Kt, qt = "__ reactEventHandlers $" + Kt, Yt = {getClosestInstanceFromNode: p, getInstanceFromNode: function (e) {var t = e [zt]; retornar t? t.tag === Lt || t.tag === Ut: t._hostNode === e: t: null: (t = p (e), null! = t && t._hostNode === e: t: null)}, getNodeFromInstance: function (e ) {if (e.tag === Lt || e.tag === Ut) retorna e.stateNode; if (void 0 === e._hostNode && r ("33"), e._hostNode) retorna e._hostNode ; para (var t = [] ;! e._hostNode;) t.push (e), e._hostParent || r ("34"), e = e._hostParent; for (; t.length; e = t .pop ()) l (e, e._hostNode); return e._hostNode}, precacheChildNodes: l, precacheNode: c, uncacheNode: function (e) {var t = e._hostNode; t && (delete t [zt], e._hostNode = null)}, precacheFiberNode: function (e, t) {t [zt] = e}, getFiberCurrentPropsFromNode: function (e) {return e [qt] || null}, updateFiberProps: function (e, t) {e [qt] = t}}, $ t = {remove: function (e) {e._reactInternalFiber = void 0}, get: function (e) {retorna e._reactInternalFiber}, possui: function (e) {return void 0! == e._reactInternalFiber}, defina: função (e, t) {e._reactInternalFiber = t}},Qt = {ReactCurrentOwner: mt .__ SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner}, Gt = {NoEffect: 0, PerformedWork: 1, Colocação: 2, Atualização: 4, PlacementAndUpdate: 6, Exclusão: 6, Exclusão: 6, Exclusão: , Ref: 128}, Xt = Dt.HostComponent, Jt = Dt.HostRoot, Zt = Dt.HostPortal, pt = Dt.HostText, tn = Gt.NoEffect, nn = Gt.Placement, rn = {isFiberMounted: function (e ) {return 2 === d (e)}, isMounted: function (e) {return !! (e = $ t.get (e)) && 2 === d (e)}, findCurrentFiberUsingSlowPath: m, findCurrentHostFiber: função (e) {if (! (e = m (e))) retorna nulo; para (var t = e ;;) {if (t.tag === Xt || t.tag === pt) return t; if (t.child) t.child.return = t, t = t.child; else {if (t === e) break; for (;! t.sibling;) {if (! t.return || t.return === e) return null; t = t.return} t.sibling.return = t.return, t = t.sibling}} return null}, findCurrentHostFiberWithNoPortals: function (e) {if (! (e = m (e))) retorna nulo; para (var t = e ;;) {if (t.tag === Xt || t.tag === pt) return t; if (t.child && t.tag! == Zt) t.child.return = t, t = t.child; else {if (t === e) break; for (; ! t.sibling;) {if (! t.return || t.return === e) return null; t = t.return} t.sibling.return = t.return, t = t.sibling}} return null}}, em = {_ catchError: null, _hasCaughtError:! 1, _rethrowError: null, _hasRethrowError:! 1, injeção: {injectErrorUtils: function (e) {"function"! = tipo de e.invokeGuardedCallback && r ("197"), y = e.invokeGuardedCallback}}, invokeGuardedCallback: function (e, t, n, r, o, a, i, u, s) {y.apply (on, argumentos)}, invokeGuardedCallbackAndCatchFirstError: function (e, t, n , r, o, a, i, u, s) {if (on.invokeGuardedCallback.apply (this, argumentos), on.hasCaughtError ()) {var c = on.clearCaughtError (); on._hasRethrowError || (on ._hasRethrowError =! 0, on._rethrowError = c)}}, rethrowCaughtError: function () {retorna v.apply (ativado, argumentos)}, hasCaughtError: function () {retorna._hasCaughtError}, clearCaughtError: function () {if (on._hasCaughtError) {var e = on._caughtError; retornar on._caughtError = null, on._hasCaughtError =! 1, e} r ("198")}}, an = on, un = {isEndish: function (e) {return "topMouseUp" === e || "topTouchEnd" === e || "topTouchCancel" === e}, isMoveish: function (e) {return "topMouseMove "=== e ||" topTouchMove "=== e}, isStartish: function (e) {return" topMouseDown "=== e ||" topTouchStart "=== e}, executeDirectDispatch: function (e) {var t = e._dispatchListeners, n = e._dispatchInstances; return Array.isArray (t) && r ("103"), e.currentTarget = t? un.getNodeFromInstance (n): null, t = t? t (e): null, e.currentTarget = null, e._dispatchListeners = null, e._dispatchInstances = null, t}, executeDispatchesInOrder: function (e, t) {var n = e._dispatchListeners, r = e._dispatchInstances; if (Array.isArray (n)) para (var o = 0; o <n.length &&! e.isPropagationStopped (); o ++) g (e, t, n [o], r [o]); else n && g (e, t, n, r); e._dispatchListeners = null, e._dispatchInstances = null}, executeDispatchesInOrderStopAtTrue: function (e) {e: {var t = e._dispatchListeners, n = e._dispatchInstances; if (Array.isArray (t)) {for (var r = 0; r <comprimento. &&! e.isPropagationStopped (); r ++) if (t [r] (e, n [r])) {t = n [r]; break e}} else if (t && t (e, n)) {t = n; break e} t = null} retornar e._dispatchInstances = null, e._dispatchListeners = null, t}, hasDispatches: function (e) {return !! e._dispatchListeners }, getFiberCurrentPropsFromNode: function (e) {retorne Pt.getFiberCurrentPropsFromNode (e)}, getInstanceFromNode: function (e) {retorne Pt.getInstanceFromNode (e)}, getNodeFromInstance: function (e) {retorne Pt.getNodeFromInstance,) injeção: {injectComponentTree: função (e) {Pt = e}}}, sn = un, cn = nulo, ln = nulo, pn = nulo,fn = {injeção: {injectFiberControlledHostComponent: função (e) {cn = e}}, enqueueStateRestore: função (e) {ln? pn? pn.push (e): pn = [e]: ln = e}, restoreStateIfNeeded: função () {se (ln) {var e = ln, t = pn; se (pn = ln = nulo, b (e), t) para (e = 0; e <comprimento de t; e ++) b (t [e])}}}, dn =! 1, hn = {batchedUpdates: function (e, t) {if (dn) retorna k (C, e, t); dn =! 0; tenta {return k (C , e, t)} finalmente {dn =! 1, fn.restoreStateIfNeeded ()}}, injeção: {injectStackBatchedUpdates: function (e) {k = e}, injectFiberBatchedUpdates: function (e) {w = e}}}, mn = It.TEXT_NODE, yn = Dt.HostRoot, vn = [], gn = {_ ativado:! 0, _handleTopLevel: null, setHandleTopLevel: function (e) {gn._handleTopLevel = e}, setEnabled: function (e) { gn._enabled = !! e}, isEnabled: function () {return gn._enabled}, trapBubbledEvent: function (e, t, n) {return n? gt.listen (n, t, gn.dispatchEvent.bind (null , e)): null}, trapCapturedEvent: function (e, t, n) {return n? gt.capture (n, t, gn.dispatchEvent.bind (null, e)):null}, dispatchEvent: function (e, t) {if (gn._abled) {var n = T (t); if (n = Yt.getClosestInstanceFromNode (n), null === n || "number"! = tipo de n.tag || rn.isFiberMounted (n) || (n = nulo), vn.length) {var r = vn.pop (); r.topLevelType = e, r.nativeEvent = t, r.targetInst = n, e = r} else e = {topLevelType: e, nativeEvent: t, targetInst: n, ancestrais: []}; tente {hn.batchedUpdates (E, e)} finalmente {e.topLevelType = null, e.nativeEvent = nulo, e.targetInst = nulo, e.ancestors.length = 0,10> vn.length && vn.push (e)}}}}, bn = gn, kn = null, wn = {injeção: {injectEventPluginOrder: Mt. injectEventPluginOrder, injectEventPluginsByName: Mt.injectEventPluginsByName}, getListener: function (e, t) {if ("número" == tipo de e.tag) {var n = e.stateNode; if (! n) retorna nulo; var o = sn .getFiberCurrentPropsFromNode (n); if (! o) retorna null; if (n = o [t], N (t, e.type, o)) retorna null} else {if ("string" == typeof (o = e._currentElement) || "número "== tipo de o ||! e._rootNodeID) retorna nulo; se (e = o.props, n = e [t], N (t, o.type, e)) retorna nulo} retorna n &&" function " ! = typeof n && r ("231", t, typeof n), n}, extractEvents: function (e, t, n, r) {para (var o, a = Mt.plugins, i = 0; i <a. comprimento; i ++) {var u = a [i]; u && (u = u.extractEvents (e, t, n, r)) && (o = P (o, u))} retornar o}, enfileirarEvents: function ( e) {e && (kn = P (kn, e))}, processEventQueue: function (e) {var t = kn; kn = null, e? O (t, x): O (t, _), kn && r ( "95"), an.rethrowCaughtError ()}}; yt.canUseDOM && (Ot = document.implementation && document.implementation.hasFeature &&! 0! == document.implementation.hasFeature ("", "")); var Cn = {animationend : R ("Animation", "AnimationEnd"), animationiteration: R ("Animation", "AnimationIteration"), animationstart: R ("Animation "," AnimationStart "), transição: R (" Transition "," TransitionEnd ")}, Tn = {}, En = {}; yt.canUseDOM && (En = document.createElement (" div "). Style," AnimationEvent "na janela || (excluir Cn.animationend.animation, excluir Cn.animationiteration.animation, excluir Cn.animationstart.animation)," TransitionEvent "na janela || excluir Cn.transitionend.transition); var Pn = {topAbort: "abortar", topAnimationEnd: A ("animationend") || "animationend", topAnimationIteration: A ("animationiteration") || "animationiteration", topAnimationStart: A ("animationstart") || "animationstart", topBlur: "blur ", topCancel:" cancel ", topCanPlay:" canplay ", topCanPlayThrough:" canplaythrough ", topChange:" change ", topClick:"clique em ", topClose:" close ", topCompositionEnd:" compositionend ", topCompositionStart:" compositionstart ", topCompositionUpdate:" compositionupdate ", topContextMenu:" contextmenu ", topCopy:" copy ", topCut:" cut ", topDoubleClick:" dblclick " , topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange : "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "finalizado", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: " pressionamento de tecla ", topKeyUp:"keyup ", topLoadedData:" loadingdata ", topLoad:" load ", topLoadedMetadata:" loadingmetadata ", topLoadStart:" loadstart ", topMouseDown:" mousedown ", topMouseMove:" mousemove ", topMouseOut:" mouseout ", topMouseOver:" mouseover " , topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked : "seeked", topSeeking: "buscando", topSelectionChange: "selectionchange", topStalled: "parado", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: " touchcancel ", topTouchEnd:"touchend ", topTouchMove:" touchmove ", topTouchStart:" touchstart ", topTransitionEnd: A (" transiçãoend ") ||" transiçãoend ", topVolumeChange:" volumechange ", topWaiting:" waiting ", topWheel:" wheel "}, On = {}, Sn = 0, xn = "_ID reactListeners" + ("" + Math.random ()). Slice (2), _ n = vt ({}, {handleTopLevel: function (e, t, n, r) { e = wn.extractEvents (e, t, n, r), wn.enqueueEvents (e), wn.processEventQueue (! 1)}}, {setEnabled: função (e) {bn && bn.setEnabled (e)}, isEnabled: function () {return! (! bn ||! bn.isEnabled ())}, listenTo: function (e, t) {var n = F (t); e = Mt.registrationNameDependencies [e]; for (var r = 0; r <e.length; r ++) {var o = e [r]; n.hasOwnProperty (o) && n [o] || ("roda superior" === o? M ("roda")? Bn. trapBubbledEvent ("roda superior", "roda", t): M ("roda do mouse")? bn.trapBubbledEvent ("topWheel", "mousewheel", t): bn.trapBubbledEvent ("topWheel", "DOMMouseScroll", t): "topScroll" === o? bn.trapCapturedEvent ("topScroll", "scroll", t) : "topFocus" === o || "topBlur" === o? (bn.trapCapturedEvent ("topFocus", "foco", t), bn.trapCapturedEvent ("topBlur", "blur", t), n .topBlur =! 0, n.topFocus =! 0): "topCancel" === o? (M ("cancelar",! 0) && bn.trapCapturedEvent ("topCancel", "cancelar", t), n.topCancel =! 0): "topClose" === o? (M ("fechar",! 0) && bn.trapCapturedEvent ("topClose", "fechar", t), n.topClose =! 0): Pn.hasOwnProperty ( o) && bn.trapBubbledEvent (o, Pn [o], t), n [o] =! 0)}}, isListeningToAllDependencies: função (e, t) {t = F (t), e = Mt.registrationNameDependencies [e]; para (var n = 0; n <e.length; n ++) {var r = e [n]; se (! t.hasOwnProperty (r) ||! t [r]) retornar! 1} return! 0}, trapBubbledEvent: function (e, t, n) {return bn.trapBubbledEvent (e, t, n)}, trapCapturedEvent: function (e, t, n) {return bn.trapCapturedEvent (e, t, n) )}}), Nn = {animationIterationCount:! 0, borderImageOutset:! 0, borderImageSlice:! 0, borderImageWidth:! 0, boxFlex:! 0, boxFlexGroup:! 0, boxOrdinalGroup:! 0, columnCount:! 0, colunas: ! 0, flex:! 0, flexGrow:! 0, flexPositive:! 0, flexShrink:! 0, flexNegative:! 0, flexOrder:! 0, gridRow:! 0, gridRowEnd:! 0, gridRowSpan:! 0, gridRowStart: ! 0, gridColumn:! 0, gridColumnEnd:! 0, gridColumnSpan:! 0, gridColumnStart:! 0, fontWeight:! 0, lineClamp:! 0, lineHeight:! 0, opacidade:! 0, order:! 0, órfãos: ! 0, tabSize:! 0, viúvas:! 0, zIndex:! 0, zoom:! 0, fillOpacity:! 0, floodOpacity:! 0, stopOpacity:! 0, strokeDasharray:! 0, strokeDashoffset:! 0, strokeMiterlimit: ! 0,strokeOpacity:! 0, strokeWidth:! 0}, Mn = ["Webkit", "ms", "Moz", "O"]; Object.keys (Nn) .forEach (function (e) {Mn.forEach (function (t) {t = t + e.charAt (0) .toUpperCase () + e.substring (1), Nn [t] = Nn [e]})}); var Rn = {isUnitlessNumber: Nn, shorthandPropertyExpansions: {background: {backgroundAttachment:! 0, backgroundColor:! 0, backgroundImage:! 0, backgroundPositionX:! 0, backgroundPositionY:! 0, backgroundRepeat:! 0}, backgroundPosition: {backgroundPositionX:! 0, backgroundPositionY:! 0}, borda : {borderWidth:! 0, borderStyle:! 0, borderColor:! 0}, borderBottom: {borderBottomWidth:! 0, borderBottomStyle:! 0, borderBottomColor:! 0}, borderLeft: {borderLeftWidth:! 0, borderLeftStyle:! 0, borderLeftColor:! 0}, borderRight: {borderRightWidth:! 0, borderRightStyle:! 0, borderRightColor:! 0}, borderTop: {borderTopWidth:! 0, borderTopStyle:! 0, borderTopColor:! 0}, fonte: {fontStyle :! 0, fonte! 0, fontWeight:! 0, fontSize:! 0, lineHeight:! 0, fontFamily:! 0}, estrutura de tópicos: {outlineWidth:! 0, outlineStyle:! 0, estrutura de tópicos:! 0}}}, An = Rn.isUnitlessNumber , Fn =! 1; if (yt.canUseDOM) {var jn = document.createElement ("div"). Style; tente {jn.font = ""} capturar (e) {Fn =! 0}} var Dn, Em = {createDangerousStringForStyles: function () {}, setValueForStyles: function (e, t) {e = e.style; for (var n in t) if (t.hasOwnProperty (n)) {var r = 0 === n.indexOf ("-"), o = n, a = t [n]; if (o = null == a || "booleano" == tipo de a || "" === a? "": r || "número"! = tipo de a || 0 === a || An.hasOwnProperty (o) && An [o]? ("" + a) .trim (): a + "px", "float" = == n && (n = "cssFloat"), r) e.setProperty (n, o); else if (o) e [n] = o; else if (r = Fn && Rn.shorthandPropertyExpansions [n]) for (var i em r) e [i] = ""; caso contrário, e [n] = ""}}},Ln = new RegExp ("^ [" + jt.ATTRIBUTE_NAME_START_CHAR + "] [" + jt.ATTRIBUTE_NAME_CHAR + "] * $"), Un = {}, Hn = {}, Bn = {setAttributeForID: function (e, t) { e.setAttribute (jt.ID_ATTRIBUTE_NAME, t)}, setAttributeForRoot: function (e) {e.setAttribute (jt.ROOT_ATTRIBUTE_NAME, "")), getValueForProperty: function () {}, getValueForAttribute: function () {}, setValueForAttribute: function () {} função (e, t, n) {var r = jt.getPropertyInfo (t); if (r && jt.shouldSetAttribute (t, n)) {var o = r.mutationMethod; o? o (e, n): null == n || r.hasBooleanValue &&! n || r.hasNumericValue && isNaN (n) || r.hasPositiveNumericValue && 1> n || r.hasOverloadedBooleanValue &&! 1 === n? Bn.deleteValueForProperty (e, t): r.m r.propertyName] = n: (t = r.attributeName, (o = r.attributeNamespace)? e.setAttributeNS (o, t, "" + n): r.hasBooleanValue || r.hasOverloadedBooleanValue &&! 0 === n? E.setAttribute (t, ""): e.setAttribute (t, "" + n))} else Bn.setValueForAttribute (e, t, jt.shouldSetAttribute (t, n)? N : null)}, setValueForAttribute: function (e, t, n) {j (t) && (null == n? e.removeAttribute (t): e.setAttribute (t, "" + n))}, deleteValueForAttribute: função (e, t) {e.removeAttribute (t)}, deleteValueForProperty: função (e, t) {var n = jt.getPropertyInfo (t); n? (t = n.mutationMethod)? t (e, nulo 0 ): n.mustUseProperty? e [n.propertyName] =! n.hasBooleanValue && "": e.removeAttribute (n.attributeName): e.removeAttribute (t)}}, Wn = Bn, Vn = Qt.ReactDebugCurrentFrame, Kn = {current: null, phase: null, resetCurrentFiber: function () {Vn.getCurrentStack = null, Kn.current = null, Kn.phase = null}, setCurrentFiber: function (e, t) {Vn.getCurrentStack = D, Kn .current = e, Kn.phase = t}, getCurrentFiberOwnerName: function () {return null}, getCurrentFiberStackAddendum:D}, zn = Kn, qn = {getHostProps: function (e, t) {var n = t.valor, r = t.checked; return vt ({type: void 0, step: void 0, step: void 0, min: void 0 , max: void 0}, t, {defaultChecked: void 0, defaultValue: void 0, valor: null! = n? n: e._wrapperState.initialValue, marcado: null! = r? r: e._wrapperState.initialChecked} )}, initWrapperState: function (e, t) {var n = t.defaultValue; e._wrapperState = {initialChecked: null! = t.checked? t.checked: t.defaultChecked, initialValue: null! = t.value? t.value: n, controlado: "caixa de seleção" === t.type || "radio" === t.type? null! = t.checked: null! = t.value}}, updateWrapper: function (e , t) {var n = t.checked; null! = n && Wn.setValueForProperty (e, "verificado", n ||! 1), n ​​= t.valor, null! = n? 0 === n && "" = == e.value? e.value = "0": "number" === t.type? (t = parseFloat (e.value) || 0, (n! = t || n == t && e.value ! = n) && (e.value = "" + n)): e.value! == ""+ n && (e.value =" "+ n) :( null == t.value && null! = t.defaultValue && e.defaultValue! ==" "+ t.defaultValue && (e.defaultValue =" "+ t.defaultValue), null == t.checked && null! = t.defaultChecked && (e.defaultChecked = !! t.defaultChecked))}, postMountWrapper: função (e, t) {switch (t.type) {case "submit": case "reset" : break; case "color": case "date": case "datetime": case "datetime-local": case "month": case "time": case "week": e.value = "" e.value = e.defaultValue; break; padrão: e.value = e.value} t = e.name, ""! == t && (e.name = ""), e.defaultChecked =! e.defaultChecked, e.defaultChecked =! e.defaultChecked, ""! == t && (e.name = t)}, restoreControlledState: function (e, t) {qn.updateWrapper (e, t); var n = t.nome; if ("radio" === t.type && null! = n) {for (t = e; t.parentNode;) t = t.parentNode; for (n = t.querySelectorAll ("input [name =" + JSON.stringify ("" + n) + '] [type = "radio"]'), t = 0; t <comprimento n; t ++) {var o = n [t]; if (o! == e && o .form === e.form) {var a = Yt.getFiberCurrentPropsFromNode (o); a || r ("90"), qn.updateWrapper (o, a)}}}}}, Yn = qn, $ n = {validateProps: function () {}, postMountWrapper: function (e, t) {null! = valor t && e.setAttribute ("valor", valor t))}, getHostProps: função (e, t) {return e = vt ({filhos: nulo 0}, t), (t = I (t. crianças)) && (e.children = t), e}}, Qn = {getHostProps: function (e, t) {return vt ( {}, t, {valor: void 0})}, initWrapperState: function (e, t) {var n = t.valor; e._wrapperState = {initialValue: null! = n? n: t.defaultValue, wasMultiple: postmountWrapper: function (e, t) {e.multiple = !! t.multiple; var n = t.valor; null! = n? L (e, !! t.multiple, n): null! = t.defaultValue && L (e, !! t.multiple, t.defaultValue)}, postUpdateWrapper: function (e, t) { e._wrapperState.initialValue = void 0; var n = e._wrapperState.wasMultiple; e._wrapperState.wasMultiple = !! t.multiple; var r = t.value; null! = r? L (e, !! t. múltiplo, r): n! == !! t.multiple && (null! = t.defaultValue? L (e, !! t.multiple, t.defaultValue): L (e, !! t.multiple, t.multiple ? []: ""))}, restoreControlledState: function (e, t) {var n = t.value; null! = n && L (e, !! t.multiple, n)}}, Gn = {getHostProps: function (e, t) {return null! = t.dangerouslySetInnerHTML && r ("91"), vt ({}, t, {value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue})} , initWrapperState: function (e, t) {var n = valor t, o = n; nulo == n && (n = valor padrão.de, t = t crianças, nulo! = t && (nulo! = Você deve evitar fornecer um argumento do segundo estado para enviar quando o primeiro argumento for um objeto semelhante a local que já possui estado; é ignorado "); var r = (0, c.createLocation) (e, n, v (), _. localização); m.confirmTransitionTo (r," PUSH ", t, função (e) {if (e ) {var t = _. index, n = t + 1, o = _. entradas.slice (0); o.length> n? o.splice (n, o.length-n, r): o.push (r), y ({ação: "PUSH", local: r, índice: n, entradas: o})}})}, C = função (e, n) {(0, u.default) (! ( "object" === (void 0 === e? "indefinido": o (e)) && void 0! == e.state && void 0! == n), "Você deve evitar fornecer um argumento de segundo estado para substituir quando o 1º argumento é um objeto de localização que já possui estado; é ignorado "); var r = (0, c.createLocation) (e, n, v (), _. location); m.confirmTransitionTo (r, "SUBSTITUIR", t, função (e) {e && (_. Entradas [_. Índice] = r, y ({ação:reateElement (la, {render: function (t) {return aacreateElement (e, p ({}, o, t, {ref: n}))}})); return t.displayName = "withRouter (" + (e .displayName || e.name) + ")", t.WrappedComponent = e, t.propTypes = {wrapComponentRef: uafunc}, c () (t, e)}; ta = f}, função (e, t, n) {"use strict"; var r = {childContextTypes:! 0, contextTypes:! 0, defaultProps:! 0, displayName:! 0, getDefaultProps:! 0, mixins:! 0, propTypes:! 0, tipo :! 0}, o = {nome:! 0, comprimento:! 0, protótipo:! 0, chamador:! 0, chamado:! 0, argumentos:! 0, arity:! 0}, a = Object.defineProperty, i = Object.getOwnPropertyNames, u = Object.getOwnPropertySymbols, s = Object.getOwnPropertyDescriptor, c = Object.getPrototypeOf, l = c && c (Objeto); e.exports = função e (t, n, p) {if ("string"! = tipoof n) {if (l) {var f = c (n); f && f! == l && e (t, f, p)} var d = i (n); u && (d = d.concat (u (n)) )); for (var h = 0; h <comprimento.d; ++ h) {var m = d [h]; if (!(r [m] || o [m] || p && p [m])) {var y = s (n, m); tente {a (t, m, y)} captura (e) {}}} retorno t} return t}}, function (e, t, n) {"use strict"; function r (e) {return e && e .__ esModule? e: {default: e}} function o () {retorna u.default. createElement ("div", {style: k.default.root}, u.default.createElement ("h1", {style: k.default.title}, "Aplicativos de página única para páginas do GitHub"), u.default. createElement (c.default, a ({as: "a", href: "https://github.com/rafrex/spa-github-pages", estilo: k.default.repoLink}, k.default.link)) , "https://github.com/rafrex/spa-github-pages"), u.default.createElement ("nav", {style: k.default.breadcrumbs}, u.default.createElement (g.default, nulo)), u.default.createElement (l.Switch, null, u.default.createElement (l.Route, {exato:! 0, caminho: "/", componente: f.default}), u.default. createElement (l.Route,{caminho: "/ exemplo", componente: h.default}), u.default.createElement (l.Route, {component: y.default})), u.default.createElement ("div", {style: k .default.creditLine}, u.default.createElement (c.default, {as: "a", href: "http://www.rafaelpedicini.com", InteractiveChild:! 0, focus: {}, touchActive: { }, touchActiveTapOnly:! 0}, "Código e conceito por", u.default.createElement ("span", k.default.childLink, "Rafael Pedicini"))))} Object.defineProperty (t, "__ esModule", {value:! 0}); var a = Object.assign || função (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retornar e}; t.default = o; var i = n (0), u = r (i ), s = n (9), c = r (s), l = n (5), p = n (92), f = r (p), d = n (94), h = r (d) , m = n (27), y = r (m), v = n (99), g = r (v), b = n (100), k = r (b)}, função (e, t, n) {"use strict "; função r (e) {if (null === e || void 0 === e) lança novo TypeError (" Object.assign não pode ser chamado com nulo ou indefinido "); return Object (e)} var o = Object.getOwnPropertySymbols, a = Object.prototype.hasOwnProperty, i = Object.prototype.propertyIsEnumerable; e.exports = function () {try {if (! Object.assign) return! 1; var e = new String ( "abc"); if (e [5] = "de", "5" === Object.getOwnPropertyNames (e) [0]) return! 1; for (var t = {}, n = 0; n < 10; n ++) t ["_" + String.fromCharCode (n)] = n; if ("0123456789"! == Object.getOwnPropertyNames (t) .map (função (e) {return t [e]}). junção ("")) return! 1; var r = {}; return "abcdefghijklmnopqrst" .split (""). forEach (função (e) {r [e] = e}), "abcdefghijklmnopqrst" === Objeto .keys (Object.assign ({}, r)). join ("")} catch (e) {return! 1}} ()? Object.assign: function (e,t) {for (var n, u, s = r (e), c = 1; c <argumentos.length; c ++) {n = Objeto (argumentos [c]); para (var l in n) (n, l) && (s [l] = n [l]); if (o) {u = o (n); for (var p = 0; p <u.length; p ++) i.call (n , u [p]) && (s [u [p]] = n [u [p]])}} retornar s}}, função (e, t, n) {"use strict"; function r (e) {var t = o ({}, u.stateProps); retorna delete t [e], Object.keys (t)} Object.defineProperty (t, "__ esModule", {valor:! 0}), t.defaultProps = t.propTypes = void 0; var o = Object.assign || função (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n ) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retornar e}, a = n (1), i = function (e) {return e && e .__ esModule? E : {padrão: e}} (a), u = n (4), s = {}; Object.keys (u.iStates) .forEach (function (e) {s [e] = i.default.bool} ); var c = {as: i.default.oneOfType ([i.default.string, i.default.func, i.default.element]). isRequired, filhos: i.default.node, normal: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("normal")))]), passe o mouse: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("hover")))]), ativo: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("active"))]), hoverActive: i .default.oneOfType ([i.default.object, i.default.oneOf (r ("hoverActive")))]), touchActive: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("touchActive"))]), keyActive: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("keyActive")))]), foco: i.default.oneOfType ([i .default.object, i.default.oneOf (r ("focus"))]), focusFromTab: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("focusFromTab"))]] ), focusFromTouch: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("focusFromTouch")))]), focusFromMouse: i.default.oneOfType ([i.default.object, i.default.oneOf (r ("focusFromMouse")))]), forceState: i.default.shape ({iState: i.default.oneOf (Object.keys (u. iStates)), foco: i.default.oneOf ([! 1, "tab", "mouse", "touch"])}), initialState: i.default.shape ({iState: i.default.oneOf (Object .keys (u.iStates)), foco: i.default.oneOf ([! 1, "tab", "mouse", "touch"])}), estilo: i.default.object, className: i.default .string, wrapperStyle: i.default.object, wrapperClassName: i.default.string, onStateChange: i.default.func, setStateCallback: i.default.func, onClick: i.default.func, onTapTwo: i.default.func , onTapThree: i.default.func, onTapFour: i.default.func, tapTimeCutoff: i.default.number, onMouseEnter: i.default.func, onMouseLeave: i.default.func, onMouseMove: i.default.func, onMouseDown : i.default.func, onMouseUp: i.default.func, onTouchStart: i.default.func, onTouchMove: i.default.func, onTouchEnd: i.default.func, onTouchCancel: i.default.func, onFocus: i.default.func, onBlur: i.default.func, onKeyDown: i.default. A função `` i '' foi criada com o intuito de facilitar o acesso a informações sobre o uso de aplicativos, como por exemplo, o uso de cookies, o que facilita a navegação no site e o uso de cookies. touchActiveTapOnly: i.default.bool, extraTouchNoTap: i.default.bool, focusToggleOff: i.default.bool, stylePriority: i.default.shape (s), nonContainedChild: i.default.bool, InteractiveChild: i.default.bool }, l = {tapTimeCutoff: u.defaultTapTimeCutoff}; t.propTypes = c, t.defaultProps = l}, função (e, t, n) {"use strict"; function r (e) {return e && e .__ esModule? e: {default: e}} função o (e, t, n, r) {return e && (t || n)? "hybrid": e && Object.keys (r.detectHover) .filter (function (e) {return "atualização"! == e}).every (function (e) {return! 1 === r.detectHover [e]}) && Object.keys (r.detectPointer) .filter (função (e) {return "update"! == e}). every ( função (e) {return! 1 === r.detectPointer [e]})? window.navigator && / android / .test (window.navigator.userAgent.toLowerCase ())? "touchOnly": "hybrid": e? "touchOnly": "mouseOnly"} Object.defineProperty (t, "__ esModule", {value:! 0}); var a = n (82), i = r (a), u = n (83), s = r (u), c = n (84), l = r (c), p = n (85), f = r (p), d = {estado: {detectHover: i.default, detectPointer: s.default , detectTouchEvents: l.default, detectPassiveEvents: f.default}, atualização: function () {d.state.detectHover.update (), d.state.detectPointer.update (), d.state.detectTouchEvents.update (), d.state.detectPassiveEvents.update (), d.updateOnlyOwnProperties ()}, updateOnlyOwnProperties: function () {"indefinido"! = tipo de janela && (d.passiveEvents = d.state.detectPassiveEvents.hasSupport ||! 1, d.hasTouch = d.state.detectTouchEvents.hasSupport ||! 1, d.deviceType = o (d.hasTouch, d.state.detectHover.anyHover, d. state.detectPointer.anyFine, d.state), d.hasMouse = "touchOnly"! == d.deviceType, d.primaryInput = "mouseOnly" === d.deviceType && "mouse" || "touchOnly" === d .deviceType && "touch" || d.state.detectHover.hover && "mouse" || d.state.detectHover.none && "touch" || "mouse", / windows / .test (window.navigator.userAgent.toLowerCase ()) ) && / chrome / .test (window.navigator.userAgent.toLowerCase ()) && parseInt (/ Chrome \ / ([0-9.] +) /. exec (navigator.userAgent) [1], 10)> = 59 && d .hasTouch && (d.deviceType = "híbrido", d.hasMouse =! 0, d.primaryInput = "mouse"))}}; d.updateOnlyOwnProperties (), t.default = d}, função (e, t, n) {"use strict"; Object.defineProperty (t, "__ esModule", {valor:! 0}); var r = {update: function () {"undefined"! = typeof window && "function" == typeof window.matchMedia && (r.hover = window.matchMedia ("(hover: hover)"). corresponde, r.none = window.matchMedia ("(hover : none) "). corresponde || window.matchMedia (" (hover: sob demanda) "). corresponde, r.anyHover = window.matchMedia (" (any-hover: hover) "). corresponde a r.anyNone = window.matchMedia ("(any-hover: none)"). corresponde || window.matchMedia ("(any-hover: on-demand)"). corresponde)}}; r.update (), t.default = r}, função (e, t, n) {"use strict"; Object.defineProperty (t, "__ esModule", {value:! 0}); var r = {update: function () {"undefined"! = tipo de janela && "função "== tipo de janela.matchMedia && (r.fine = janela.matchMedia (" (ponteiro: fino) "). corresponde, r.coarse = janela.matchMedia (" (ponteiro: grosso) "). corresponde, r.nenhum = window.matchMedia ("(ponteiro: nenhum)"). corresponde, r.anyFine = window.matchMedia ("(qualquer-ponteiro: fino)"). corresponde, r.anyCoarse = window.matchMedia ("(qualquer-ponteiro : grosseiro) "). correspondências, r.anyNone = window.matchMedia (" (qualquer ponteiro: nenhum) "). correspondências)}}; r.update (), t.default = r}, função (e, t , n) {"use strict"; Object.defineProperty (t, "__ esModule", {value:! 0}); var r = {update: function () {"undefined"! = tipo de janela && (r.hasSupport = " ontouchstart "na janela, r.browserSupportsApi = Boolean (window.TouchEvent))}}; r.update (), t.default = r}, função (e, t, n) {" use strict "; Object.defineProperty ( t, "__ esModule",{value:! 0}); var r = {update: function () {if ("undefined"! = typeof window && "function" == typeof window.addEventListener) {var e =! 1, t = Object.defineProperty ( {}, "passivo", {get: function () {e =! 0}}), n = function () {}; window.addEventListener ("testPassiveEventSupport", n, t), window.removeEventListener ("testPassiveEventSupport" , n, t), r.hasSupport = e}}}; r.update (), t.default = r}, função (e, t, n) {"use strict"; function r (e, t) { Se (e.children! == t.children) retornar! 1; var n = Object.keys (t), o = t.forceState? -1: 0, u = e.forceState? -1: 0; if ( n.length + o! == Object.keys (e) .length + u) return! 1; for (var s = 0; s <n.length; s ++) if ("forceState"! == n [s] ) {if (! Object.prototype.hasOwnProperty.call (e, n [s])) retorna! 1; if (t [n [s]]! == e [n [s]]) if ("como" === n [s]) {if (! a.default.isValidElement (e.as) ||! a.default.isValidElement (t.as)) return! 1;if (e.as.type! == t.as.type) retorna! 1; if (! r (e.as.props, t.as.props)) retorna! 1} else if (! i.stateProps [ n [s]] ||! function (n) {return !! i.statePropOptionKeys.some (function (e) {return t [n] [e]}) && i.statePropOptionKeys.every (function (r) {return t [n] [r] === e [n] [r]})} (n [s])) retorne! 1} retorne! 0} Object.defineProperty (t, "__ esModule", {value:! 0} ), t.default = r; var o = n (0), a = function (e) {return e && e .__ esModule? e: {padrão: e}} (o), i = n (4); e.exports = t.default}, function (e, t, n) {"use strict"; function r (e, t) {var n = {}, r = {}; retorna Object.keys (e) .forEach (function (o) {n [o] = e [o], t [o] || (r [o] = e [o])}), a.default.isValidElement (e.as)? (Object.keys ( e.as.props) .forEach (function (o) {n [o] = e.as.props [o], t [o] || (r [o] = e.as.props [o])} ), n.as = e.as.type): n.as = e.as, {mergedProps: n, passThroughProps: r}} Object.defineProperty (t, "__ esModule", {valor:! 0}), t .default = r; var o = n (0),a = function (e) {return e && e .__ esModule? e: {default: e}} (o); e.exports = t.default}, function (e, t, n) {"use strict"; function r ( e, t) {for (var n = "hoverActive"! == t || e.hoverActive? t: "hover", r = 0; "string" == tipo de n && r <10;) n = e [n] , r ++; if ("object"! == (void 0 === n? "undefined": i (n))) return {style: null, className: ""}; var o = {}; return u. statePropOptionKeys.some (function (e) {return n [e]})? (o.style = n.style || nulo, o.className = n.className || "") :( o.style = n, o .className = ""), o} função o (e) {e.active && (e.hoverActive || (e.hoverActive = e.active), e.touchActive || (e.touchActive = e.active), e .keyActive || (e.keyActive = e.active)), e.focus && (e.focusFromTab || (e.focusFromTab = e.focus), e.focusFromMouse || (e.focusFromMouse = e.focus), e .focusFromTouch || (e.focusFromTouch = e.foco))} função a (e, t, n) {var r = e; retornar r + = r && t? "" + t: "" + t, r + = r && n? "" + n: "" + n} Objeto. defineProperty (t, "__ esModule", {valor:! 0}); var i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator? function (e) {retorne typeof e}: function (e) {return e && "function" == typeof Symbol && e.constructor === Symbol && e! == Symbol.prototype? "symbol": typeof e}; t.extractStyle = r, t.setActiveAndFocusProps = o, t.joinClasses = a; var u = n (4)}, função (e, t, n) {"use strict"; função r (e, t) {if (t (e)) retorna! 0; for (var n = 0; n < e.children.length; n ++) if (r (e.children [n], t)) return! 0; return! 1} Object.defineProperty (t, "__ esModule", {value:! 0}), t. padrão = r, e.exports = t.default}, função (e, t, n) {"use strict"; função r (e) {"touchstart "=== e.type? (l.touch.touchOnScreen =! 0, l.mouse.mouseOnDocument =! 1):" touchend "! == e.type &&" touchcancel "! == e.type || ( l.touch.recentTouch =! 0, p && window.clearTimeout (p), p = window.setTimeout (função () {l.touch.recentTouch =! 1, p = nulo}, c.queueTime)), 0 === e.touches.length && (l.touch.touchOnScreen =! 1)} função o (e) {l.mouse.clientX = e.clientX, l.mouse.clientY = e.clientY, l.mouse.buttons = e. botões, "mouseleave" === e.type? l.mouse.mouseOnDocument =! 1: l.mouse.mouseOnDocument =! 0} função a (e) {l.touch.recentTouch || l.touch.touchOnScreen || o (e)} function i (e) {"Enter" === e.key && (l.key.recentEnterKeyDown =! 0, f && window.clearTimeout (f), f = window.setTimeout (function () {l.key .recentEnterKeyDown =! 1, f = nulo}, c.queueTime))} função u (e) {o (e), l.mouse.mouseOnDocument =! 0} Object.defineProperty (t, "__esModule ", {valor:! 0}), t.focusRegistry = void 0, t.updateMouseFromRI = u; var s = n (18), c = n (4), l = {mouse: {mouseOnDocument:! 1, clientX: 0, clientY: 0, botões: 0}, toque em: {touchOnScreen:! 1, recentTouch:! 1}, tecla: {recentEnterKeyDown:! 1}}, p = nulo, f = nulo; c.deviceHasTouch && (0 , s.notifyOfAll) (Object.keys (c.touchEvents), r), c.deviceHasMouse && (0, s.notifyOfAll) (Object.keys (c.mouseEvents), "hybrid" === c.deviceType? a: o), (0, s.notifyOfAll) (["keydown"], i), t.focusRegistry = {foco: nulo, desfoque: nulo}, t.default = l}, função (e, t, n) { "use strict"; função r (e) {c ++, null! == s && window.clearTimeout (s), u =! 1, e.click (), u =! 0, s = window.setTimeout (function () { u =! 1, c = 0, s = nulo}, i.queueTime)} função o (e) {u && (e.stopPropagation (), e.preventDefault (), 0 == - c && (u =! 1 , null! == s && (window.clearTimeout (s), s = null)))} Object.defineProperty (t,"__esModule", {value:! 0}), t.default = r; var a = n (18), i = n (4), u =! 1, s = null, c = 0; i.deviceHasTouch && ( 0, a.notifyOfAll) (["clique"], o), e.exports = t.default}, função (e, t, n) {"use strict"; function r (e) {return e && e .__ esModule? e: {padrão: e}} função o () {retorna u.default.createElement ("div", nulo, u.default.createElement ("p", {style: d.default.p}, "Este é um exemplo de aplicativo de página única criado com o React e o React Router usando "," ", u.default.createElement (p.Code, null," BrowserRouter "),". Navegue pelos links abaixo e atualize a página ou copie / cole o URL para testar a funcionalidade de redirecionamento implantada para superar a incompatibilidade do GitHub Pages com aplicativos de página única (como este). "), u.default.createElement (" p ", {style: d.default.p}," Consulte o " ,função (e) {retornar u.default.createElement (c.default, a ({as: "a"}, d.default.link, {href: "https://github.com/rafrex/spa-github- pages # readme "})," repo readme ")} ()," para obter instruções sobre como usar este padrão para implantar seu próprio aplicativo de página única usando as páginas do GitHub. "), u.default.createElement (" div ", { estilo: d.default.pageLinkContainer}, u.default.createElement (c.default, a ({as: l.Link}, d.default.link, {to: "/ example"}), "página de exemplo") ), u.default.createElement ("div", {estilo: d.default.pageLinkContainer}, u.default.createElement (c.default, a ({as: l.Link}, d.default.link, {para : "/ example / two-deep? field1 = foo & field2 = bar # boom!"}), "Exemplo dois deep com consulta e hash")))} Object.defineProperty (t, "__ esModule", {value:! 0} ); var a = Object.assign || função (e) {for (var t = 1;t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} return e}; t.default = o; var i = n (0), u = r (i), s = n (9), c = r (s), l = n (5), p = n (3) ), f = n (93), d = r (f)}, função (e, t, n) {"use strict"; Object.defineProperty (t, "__ esModule", {value:! 0}); var r = n (3), o = função (e) {return e && e .__ esModule? e: {padrão: e}} (r), a = Object.create (o.default); a.pageLinkContainer = {margin: " 1vh 0 "}, t.default = a}, function (e, t, n) {" use strict "; function r (e) {return e && e .__ esModule? E: {padrão: e}} function o () { retornar u.default.createElement (l.Switch, null, u.default.createElement (l.Route, {exato:! 0, caminho: "/ example / two-deep", render: function (e) {var t = e.location; return u.default.createElement ("div", null, u.default.createElement (v, null), u.default.createElement (f.default,{location: t}))}}), u.default.createElement (l.Route, {exato:! 0, caminho: "/ example", render: function () {retorna u.default.createElement ("div" , nulo, u.default.createElement (v, nulo), u.default.createElement ("div", {estilo: y.default.pageLinkContainer}, u.default.createElement (c.default, a ({as: l .Link}, y.default.link, {to: "/ example / two-deep? Field1 = foo & field2 = bar # boom!"})), "Exemplo dois deep with query and hash")))}}), u .default.createElement (l.Route, {component: h.default}))} Object.defineProperty (t, "__ esModule", {value:! 0}); var a = Object.assign || função (e) { for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n, r) && (e [r] = n [r])} retorna e}; t.default = o; vari = n (0), u = r (i), s = n (9), c = r (s), l = n (5 ), p = n (95), f = r (p), d = n (27), h = r (d), m = n (98), y = r (m),v = function () {return u.default.createElement ("p", {style: y.default.p}, "Esta é uma página de exemplo. Atualize a página ou copie / cole o URL para testar a funcionalidade de redirecionamento ( esta mesma página deve ser carregada após o redirecionamento). ")}}, function (e, t, n) {" use strict "; function r (e) {return e && e .__ esModule? e: {padrão: e}} function o (e) {var t = e.localização, n = ""! == t.search, r = ""! == t.hash; retorna u.default.createElement ("div", null, u.default. createElement ("div", {style: m.default.lineContainer}, u.default.createElement ("div", null, function () {return n? "Os pares de valores de campo da string de consulta são:": "Nenhuma consulta string na url "} ()), u.default.createElement (" ul ", null, function () {return n? t.search.replace ("? "," "). split (" & ").map (function (e) {return e.split ("=")}). map (function (e) {return [e [0], e.slice (1) .join ("=")]}): []} (). map (função (e, t) {retorna u.default.createElement (d.Li, {key: "" + e [0] + e [1] + t}, e [0] + ":" + e [1])}))), u.default.createElement ("div", {estilo: m.default.lineContainer}, u.default.createElement ("div", null, function () { return r? "O fragmento de hash é:": "Nenhum fragmento de hash no URL"} ()), u.default.createElement ("ul", nulo, r && u.default.createElement (d.Li, null, t. hash.slice (1)))), function () {if (n && r) return null; var e = n? t.search: "? field1 = foo & field2 = bar", o = r? t.hash: "# boom ! ", i =" "; retorna n &&! r && (i =" Mostrar com fragmento de hash ") ,! n && r && (i =" Mostrar com cadeia de caracteres de consulta "), n || r || (i ="Mostrar com sequência de caracteres de consulta e fragmento de hash "), u.default.createElement (" div ", {estilo: m.default.lineContainer}, u.default.createElement (p.default, a ({as: f.Link, to : "/ example / two-deep" + e + o}, m.default.link), i))} ())} Object.defineProperty (t, "__ esModule", {valor:! 0}); var a = Função Object.assign || (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call ( n, r) && (e [r] = n [r])} retornar e}; t.default = o; vari = n (0), u = r (i), s = n (1), c = r (s), l = n (9), p = r (l), f = n (5), d = n (3), h = n (96), m = r (h), y = {location: c.default.object.isRequired}; o.propTypes = y}, função (e, t, n) {"use strict"; Object.defineProperty (t, "__ esModule", {value:! 0}) ; var r = n (3), o = function (e) {return e&& .__ esModule? e: {padrão: e}} (r), a = Object.create (o.default); a.lineContainer = {margin : "3vh 0"}, t.default = a}, function (e, t, n) {"use strict"; Object.defineProperty (t, "__ esModule", {value:! 0}); var r = n (3), o = function (e ) {return e && e .__ esModule? e: {padrão: e}} (r), a = Object.create (o.default); t.default = a}, função (e, t, n) {"use strict" ; Object.defineProperty (t, "__ esModule", {valor:! 0}); var r = n (3), o = function (e) {return e && e .__ esModule? E: {padrão: e}} (r) , a = Object.create (o.default); a.pageLinkContainer = {margin: "1vh 0"}, t.default = a}, function (e, t, n) {"use strict"; function r (e ) {return e && e .__ esModule? e: {padrão: e}} função o (e) {var t = e.match, n = y [t.url.split ("/"). slice (-1)], r = void 0 === n? "/": t.url; retorna s.default.createElement ("span", nulo, s.default.createElement (d.default, i ({as: p.Link}, m.default.link, {to: r}), n || "Página não encontrada") ,! t.isExact &&n && "/", n && s.default.createElement (p.Route, {path :( "/" === t.url? "": t.url) + "/: path", componente: o}))} função a () {retornar s.default.createElement (p.Route, {caminho: "/", componente: o})} Object.defineProperty (t, "__ esModule", {valor:! 0}); var i = Função Object.assign || (e) {for (var t = 1; t <argumentos.length; t ++) {var n = argumentos [t]; for (var r in n) Object.prototype.hasOwnProperty.call (n , r) && (e [r] = n [r])} retorna e}; t.default = a; var u = n (0), s = r (u), c = n (1), l = r (c), p = n (5), f = n (9), d = r (f), h = n (3), m = r (h), y = {"": "Casa", exemplo: "Exemplo", "duas profundidades": "Duas profundidades"}; o.propTypes = {match: l.default.object.isRequired}}, função (e, t, n) {"use strict"; Object .defineProperty (t, "__ esModule", {value:! 0}); var r = n (3), o = function (e) {return e && e.__esModule? e: {padrão: e}} (r), a = Object.create (o.default); a.root = {fontFamily: "helvetica, sans-serif", fontWeight: "300", fontSize: "16px ", letterSpacing:" 0.025em ", preenchimento:" 3vh 0 12vh 0 ", largura:" 500px ", maxWidth:" calc (100vw - 40px) ", posição:" relativa ", à esquerda:" 50vw ", WebkitTransform:" traduzir (-50%, 0) ", MozTransform:" traduzir (-50%, 0) ", msTransform:" traduzir (-50%, 0) ", OTransform:" traduzir (-50%, 0) ", transformar : "translate (-50%, 0)", WebkitTextSizeAdjust: "none", MozTextSizeAdjust: "none", msTextSizeAdjust: "none", textSizeAdjust: "none"}, a.title = {fontSize: "20px", marginBottom: "0.5vh"}, a.repoLink = {fontSize: "14px"}, a.breadcrumbs = {margin: "3vh 0"}, a.creditLine = {color: "# A0A0A0", tamanho da fonte: "14 px", marginTop: "50 px"}, t.default = a}]);
